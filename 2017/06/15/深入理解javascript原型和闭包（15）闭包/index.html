<!DOCTYPE html>
<html lang=>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  
    <link rel="icon" href="">
  
    
  <title>深入理解javascript原型和闭包（15）闭包 | lf小哇</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>lf小哇</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>深入理解javascript原型和闭包（15）闭包</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2017/06/15</time>
            
            
          </div>
          <p>前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。</p>
<p>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。</p>
<font color="red" face="黑体" size="4">但是你只需要知道应用的两种情况即可——1、函数作为返回值，2、函数作为参数传递。</font>

<h3 id="第一，函数作为返回值"><a href="#第一，函数作为返回值" class="headerlink" title="第一，函数作为返回值"></a>第一，函数作为返回值</h3><p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/1.png" alt="bg"></p>
<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p>
<h3 id="第二，函数作为参数被传递"><a href="#第二，函数作为参数被传递" class="headerlink" title="第二，函数作为参数被传递"></a>第二，函数作为参数被传递</h3><p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/2.png" alt="bg"></p>
<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>
<p>上一节讲到自由变量跨作用域取值时，曾经强调过：<font color="red" face="黑体" size="4">要去创建这个函数的作用域取值，而不是“父作用域”。</font>理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（不明白的朋友一定要去上一节看看，这个很重要！）</p>
<p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p>
<p>在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p>
<p>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。<font color="red" face="黑体" size="4">这就是需要理解闭包的核心内容。</font></p>
<p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。</p>
<p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/3.png" alt="bg"></p>
<h3 id="第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。"><a href="#第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。" class="headerlink" title="第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。"></a>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</h3><p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/4.png" alt="bg"></p>
<h3 id="第二步，执行第17行代码时，调用fn-，产生fn-执行上下文环境，压栈，并设置为活动状态。"><a href="#第二步，执行第17行代码时，调用fn-，产生fn-执行上下文环境，压栈，并设置为活动状态。" class="headerlink" title="第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。"></a>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。</h3><p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/5.png" alt="bg"></p>
<h3 id="第三步，执行完第17行，fn-调用完成。按理说应该销毁掉fn-的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn-时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn-上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。"><a href="#第三步，执行完第17行，fn-调用完成。按理说应该销毁掉fn-的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn-时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn-上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。" class="headerlink" title="第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。"></a>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。<font color="red" face="黑体" size="4">注意，重点来了</font>：因为执行fn()时，<font color="red" face="黑体" size="4">返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。</font>而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</h3><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p>
<p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p>
<p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/6.png" alt="bg"></p>
<h3 id="第四步，执行到第20行，执行f1-15-，即执行bar-15-，创建bar-15-上下文环境，并将其设置为活动状态。"><a href="#第四步，执行到第20行，执行f1-15-，即执行bar-15-，创建bar-15-上下文环境，并将其设置为活动状态。" class="headerlink" title="第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。"></a>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</h3><p><img src="/2017/06/15/深入理解javascript原型和闭包（15）闭包/7.png" alt="bg"></p>
<p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p>
<p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p>
<font color="red" face="黑体" size="4">使用闭包会增加内容开销，现在很明显了吧！</font>

<p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p>
<p>闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！</p>
<p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，<font color="red" face="黑体" size="4">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，</font>因为这些BUG可能完全在你的知识范围之外。</p>
<p>到现在闭包就简单介绍完了，下一节我们再总结一下。</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一，函数作为返回值"><span class="toc-number">1.</span> <span class="toc-text">第一，函数作为返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二，函数作为参数被传递"><span class="toc-number">2.</span> <span class="toc-text">第二，函数作为参数被传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。"><span class="toc-number">3.</span> <span class="toc-text">第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二步，执行第17行代码时，调用fn-，产生fn-执行上下文环境，压栈，并设置为活动状态。"><span class="toc-number">4.</span> <span class="toc-text">第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三步，执行完第17行，fn-调用完成。按理说应该销毁掉fn-的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn-时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn-上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。"><span class="toc-number">5.</span> <span class="toc-text">第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四步，执行到第20行，执行f1-15-，即执行bar-15-，创建bar-15-上下文环境，并将其设置为活动状态。"><span class="toc-number">6.</span> <span class="toc-text">第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
