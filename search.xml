<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图片大小如何识别]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[验证图片大小 让我们看一段代码,element-ui组件中有一段限制图片大小的代码 12345const isLt2M = file.size / 1024 / 1024 &lt; 2;if (!isLt2M) &#123; this.$message.error("上传头像图片大小不能超过 2MB!");&#125; 乍一看我们可能会觉得什么鬼，那么让我们仔细的往下追究 size 拿到的是字节数 计算机存储信息的大小，最基本的单位是字节，一个汉字由两个字节组成，字母和数字由一个字节组成。 容量的单位从小到大依次是：字节（B）、KB、MB、GB、TB。它们之间的关系是 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024字节 通常人们都使用简便的叫法，把后面的“B”去掉，所以你问的1MB就是1024KB 让我们扩展一下 上传图片大小限制300k ？ 123456789101112131415161718192021function limitJpg(fileId, imgId, urlId) &#123; var max_size = 300;// 300k var tmpFile = document.getElementById(fileId); if (tmpFile.value == '' || tmpFile.value == null) &#123; alert("请上传图片"); return false; &#125; if (!/\.(gif|jpg|jpeg|png|GIF|JPG|PNG)$/.test(tmpFile.value)) &#123; alert("图片类型必须是[.gif,jpeg,jpg,png]中的一种"); tmpFile.value = ""; return false; &#125; else &#123; var fileData = tmpFile.files[0]; var size = fileData.size; if (size &gt; max_size * 1024) &#123; alert("图片大小不能超过300k"); tmpFile.value = ""; &#125; else &#123; ajaxFileUpload(fileId, imgId, urlId); &#125; &#125; 所以这就是判断图片大小的方式，有问题欢迎反馈！]]></content>
  </entry>
  <entry>
    <title><![CDATA[git命令行指令]]></title>
    <url>%2F2018%2F08%2F24%2Fgit%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令行指令 Git 全局设置git config –global user.name “xx”git config –global user.email “xx@xx.com“ 创建新版本库git clone https://xx.gitcd appaixiaotouch README.mdgit add README.mdgit commit -m “add README”git push -u origin master 已存在的文件夹cd existing_foldergit initgit remote add origin https://xx.gitgit add .git commit -m “Initial commit”git push -u origin master 已存在的 Git 版本库cd existing_repogit remote add origin https://xx.gitgit push -u origin –allgit push -u origin –tags]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装和使用MongoDB]]></title>
    <url>%2F2018%2F07%2F18%2FMac-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8MongoDB%2F</url>
    <content type="text"><![CDATA[采用Homebrew:1brew install mongodb --with-openssl brew –cache 查看brew缓存地址 mongod -version 查看mongodb版本 使用启动和停止mongodb数据库 1、方法一：使用bash终端 启动：123ongod --config /usr/local/etc/mongod.conf // 启动//或mongod --dbpath . // 启动 启动成功后可以在mac的“活动监视器”中看到进程mongod，停止则关闭进程。 停止： 使用command+T在同一窗口中建立多标签终端，在新的bash中输入： 1234mongo # 进入mongo命令行&gt; use admin&gt; db.shutdownServer() # 停止&gt; ctrl+C # 退出mongo命令行 进入mongo命令行可以在mac的“活动监视器”中看到进程mongo，退出则关闭进程。 2、方法二：使用homebrew 123brew services start mongodb # 启动brew services restart mongodb # 重启brew services stop mongodb # 停止 启动成功之后： 12345678910111213141516171819202122232425&gt;mongoMongoDB shell version v4.0.0connecting to: mongodb://127.0.0.1:27017MongoDB server version: 4.0.0Server has startup warnings:2018-07-18T16:32:33.724+0800 I CONTROL [initandlisten]2018-07-18T16:32:33.724+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-07-18T16:32:33.724+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-07-18T16:32:33.724+0800 I CONTROL [initandlisten]---Enable MongoDB's free cloud-based monitoring service to collect and displaymetrics about your deployment (disk utilization, CPU, operation statistics,etc).The monitoring data will be available on a MongoDB website with a uniqueURL created for you. Anyone you share theURL with will also be able toview this page. MongoDB may use this information to make productimprovements and to suggest MongoDB products and deployment options to you.To enable free monitoring, run the following command:db.enableFreeMonitoring()--- 1234&gt; show dbsadmin 0.000GBlocal 0.000GBhelp]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈移动端rem适配]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%B5%85%E8%B0%88%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[rem是什么rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过rem计算的规则是依赖根元素,em是依赖父元素计算。 rem布局原理拿到设计稿，按照设计稿的宽去设置一个合适的rem ,配合js查询屏幕大小来改变html的font-size，从而达到适配各种屏幕的效果 rem布局优缺点优点，宽度自适应，可以完美适配不同宽度的屏幕 缺点，高度不固定，如果遇到高度要求很严格的就实现不了 网上有很多解决的方案，我常用的是 1234567891011121314151617181920212223/** * 适配移动端 * * 当拿到的设计图宽为750px时，在谷歌宽为375px的调试机上，如下设置 * * · 因为html根元素的字体大小是16px，那么换成rem单位，直接除以16就好； * （375/16 = 23.4375px）也就是说htmlDom.style.fontSize = 375/23.4375 = 16px * · 当图纸有一个宽为680px的盒子时，此时换算成rem的值为 680/16/2 = 21.25rem;也就是说680/32 */(function() &#123; //得到手机屏幕的宽度 let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; //得到html的Dom元素 let htmlDom = document.getElementsByTagName('html')[0]; //设置根元素字体大小 htmlDom.style.fontSize= htmlWidth/23.4375 + 'px';&#125;)()]]></content>
  </entry>
  <entry>
    <title><![CDATA[js获取当前域名、Url、相对路径和参数以及指定参数]]></title>
    <url>%2F2018%2F07%2F17%2Fjs%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%9F%9F%E5%90%8D%E3%80%81Url%E3%80%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[window.location下的属性说明12345678var href = window.location.href;//完整的urlvar protocol = window.location.protocol;//协议var hostname = window.location.hostname;//主机名var host = window.location.host;//主机名+端口号var port = window.location.port;//端口号var pathname = window.location.pathname;//当前URL的路径部分var search = window.location.search;//路径的查询部分var hash = window.location.hash;//开始的锚点 一、js获取当前域名有2种方法12345 //1、方法一 var domain = document.domain; //2、方法二 var domain = window.location.host; 注意问题由于获取到的当前域名不包括 http://，所以把获取到的域名赋给 a 标签的 href 时，别忘了加上 http://，否则单击链接时导航会出错。 二、获取当前Url的4种方法1234567 var url = window.location.href; var url = self.location.href; var url = document.URL; var url = document.location; 三、获取当前相对路径的方法1234567891011121314151617//首先获取 Url，然后把 Url 通过 // 截成两部分，再从后一部分中截取相对路径。如果截取到的相对路径中有参数，则把参数去掉。 function GetUrlRelativePath() &#123; var url = document.location.toString(); var arrUrl = url.split("//"); var start = arrUrl[1].indexOf("/"); var relUrl = arrUrl[1].substring(start);//stop省略，截取从start开始到结尾的所有字符 if(relUrl.indexOf("?") != -1)&#123; relUrl = relUrl.split("?")[0]; &#125; return relUrl; &#125; //调用方法：GetUrlRelativePath(); 四、获取当前Url参数的方法123456789101112//1、获取Url参数部分 function GetUrlPara() &#123; var url = document.location.toString(); var arrUrl = url.split("?"); var para = arrUrl[1]; return para; &#125; //调用方法：GetUrlPara() 五、获取指定Url参数的方法123456789101112131415161718192021222324 //paraName 等找参数的名称 function GetUrlParam(paraName) &#123; var url = document.location.toString(); var arrObj = url.split("?"); if (arrObj.length &gt; 1) &#123; var arrPara = arrObj[1].split("&amp;"); var arr; for (var i = 0; i &lt; arrPara.length; i++) &#123; arr = arrPara[i].split("="); if (arr != null &amp;&amp; arr[0] == paraName) &#123; return arr[1]; &#125; &#125; return ""; &#125; else &#123; return ""; &#125; &#125; // 调用方法：GetUrlParam("id");]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas图片问题浅析]]></title>
    <url>%2F2018%2F07%2F16%2Fcanvas%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[说一下我的业务场景 生成二维码并且在中间加上LOGO，因为LOGO是链接，所以，保存为图片的时候，会遇到跨域的问题 受限于 CORS 策略，会存在跨域问题，虽然可以使用图像（比如append到页面上）但是绘制到画布上会污染画布，一旦一个画布被污染,就无法提取画布的数据，比如无法使用使用画布toBlob(),toDataURL(),或getImageData()方法;当使用这些方法的时候 会抛出一个安全错误 1Uncaught DOMException: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported. 解决方案如下 如果是new Image()的话，要加上一下设置： 12// 引用外部图片，需设置 crossOrigin 属性，否则 toDataURL 调用异常image.setAttribute('crossOrigin', 'anonymous'); 完整如下:12345678910var canvas=document.getElementById(&quot;canvas&quot;),//获取canvas ctx = canvas.getContext(&quot;2d&quot;), //对应的CanvasRenderingContext2D对象(画笔) img = new Image(),//创建新的图片对象 base64 = &apos;&apos; ;//base64 img.src = &apos;http://www.xxxx.png&apos;;img.setAttribute(&quot;crossOrigin&quot;,&apos;Anonymous&apos;)img.onload = function()&#123;//图片加载完，再draw 和 toDataURL ctx.drawImage(img,0,0); base64 = canvas.toDataURL(&quot;image/png&quot;); &#125;; 到此时，如果你已经解决了，那么恭喜你，接下来的不用看了，如果还提示异常，接着看： 如果设置了依然不生效，无法保存为图片，那是因为缓存 当我们第一次访问时，图片加载慢，因为我们是从服务端请求而来，当我们请求下来之后，就缓存到了浏览器中。 这也就是为什么设置了属性后还报错的情况，这时候你要看看是不是同时请求了同一张图片，这种情况下，第一次请求图片他会带请求头，第二次请求这张图片时，他会直接取缓存中的数据，然后就挂了。 在图片链接后面拼接随机数。 在生成图片就OK了 分享一个链接，讲的很不错 👉https://www.jianshu.com/p/c3aa975923de 另外一篇： 👉https://www.cnblogs.com/superil/p/8462042.html 分享两个非常好的查询问题的 bug之家: https://stackoverflow.com/ 文档之家: https://developer.mozilla.org/en-US/]]></content>
  </entry>
  <entry>
    <title><![CDATA[FastClick用法]]></title>
    <url>%2F2018%2F07%2F12%2FFastClick%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为什么要使用FastClick移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件，这是为了检查用户是否在做双击。为了能够立即响应用户的点击事件，才有了FastClick。 项目地址：https://github.com/ftlabs/fastclick FastClick的使用在页面直接引入fastclick.js1&lt;script type=&apos;application/javascript&apos; src=&apos;/path/to/fastclick.js&apos;&gt;&lt;/script&gt; 1npm install fastclick 初始化FastClick实例初始化FastClick实例建议在页面的DOM文档加载完成后。 1、纯Javascript版12345if (&apos;addEventListener&apos; in document) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; FastClick.attach(document.body); &#125;, false);&#125; 2、jQuery版123$(function() &#123; FastClick.attach(document.body);&#125;); 3、类似Common JS的模块系统方式12var attachFastClick = require(&apos;fastclick&apos;);attachFastClick(document.body); 调用require(‘fastclick’)会返回FastClick.attach函数 使用needsclick过滤特定的元素如果页面上有一些特定的元素不需要使用fastclick来立刻触发点击事件，可以在元素的class上添加needsclick:1&lt;a class="needsclick"&gt;Ignored by FastClick&lt;/a&gt; 不需要使用fastclick的情况1、FastClick是不会对PC浏览器添加监听事件2、Android版Chrome 32+浏览器，如果设置viewport meta的值为width=device-width，这种情况下浏览器会马上出发点击事件，不会延迟300毫秒。1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 3、所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。4、IE11+浏览器设置了css的属性touch-action: manipulation，它会在某些标签（a，button等）禁止双击事件，IE10的为-ms-touch-action: manipulation]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue裁剪图以及扩展的知识点]]></title>
    <url>%2F2018%2F07%2F04%2Fvue%E8%A3%81%E5%89%AA%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[vue的扩展插件cropperjs满足了基本的需求，那么当裁剪完成为了base64图的时候，接下里该如何处理呢？ base64如何上传base64属于一个字符串， 那么我们需要将base64转换二进制文件对象 Blob/Base64转换 File 对象 表单中enctype=”multipart/form-data”的意思，是设置表单的MIME编码。 默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传； 只有使用了multipart/form-data，才能完整的传递文件数据，进行下面的操作. form设置了enctype=”multipart/form-data” 属性后，就是2进制传输数据了 base64转为Blob1234567891011121314dataURItoBlob(base64Data) &#123; let byteString if (base64Data.split(&apos;,&apos;)[0].indexOf(&apos;base64&apos;) &gt;= 0)&#123; byteString = atob(base64Data.split(&apos;,&apos;)[1]) &#125;else&#123; byteString = unescape(base64Data.split(&apos;,&apos;)[1]) &#125; let mimeString = base64Data.split(&apos;,&apos;)[0].split(&apos;:&apos;)[1].split(&apos;;&apos;)[0] let ia = new Uint8Array(byteString.length) for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i); &#125; return new Blob([ia], &#123;type:mimeString&#125;);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[node进阶(二)]]></title>
    <url>%2F2018%2F06%2F24%2Fnode%E8%BF%9B%E9%98%B6-%E4%BA%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[node进阶(一)]]></title>
    <url>%2F2018%2F06%2F24%2Fnode%E8%BF%9B%E9%98%B6-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[作为当前前端必须掌握的内容之一，node已经成为了前端的标配，已经再也不是以前页面仔，而是向着工程师靠拢。这就要求我们除了熟悉浏览器端的要求之外，还需要更多熟悉服务端的一些内容，那么我们一起来在node方面来进阶吧。 首先来看一个内容 开发环境和调试工具 1、环境CommonJs1234567891011121314151617这是一个JS模块管理规范JS中的模块规范（CommonJS，AMD，CMD）在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。CommonJS定义的模块分为:&#123;模块引用(require)&#125; &#123;模块定义(exports)&#125; &#123;模块标识(module)&#125;require()用来引入外部模块exports对象用于导出当前模块的方法或变量，唯一的导出口module对象就代表模块本身。 global1服务器端端没有BOM、DOM，没有了window全局对象，成了global process1全局进程 2、调试工具新建一个js 123\\app.jsconsole.log(&quot;this is test&quot;); 开启终端，跑一下 1node app 然后在输入 1node --inspect-brk app.js 会出现 123Debugger listening on ws://127.0.0.1:9229/1857a99c-6d02-4680-954d-29480f7bcc5eFor help see https://nodejs.org/en/docs/inspectorDebugger attached. 打开谷歌浏览器 1chrome://inspect 出现如下内容 点击 inspect 这就是node私底下跑的内容，它将很多我们看不到的内容进行了编译，生成了块级作用域； 3、require的特性先看一个demo 创建一个文件夹用来储存模块内容 1234567//a.jsconsole.log(&quot;this is a&quot;);let a = 1;module.exports.a = a; 在外在建一个js文件 12345// b.jslet a = require(&apos;./a&apos;);console.log(a.a) //1 到此我们来分析它的几个特性 module 被加载的时候执行，加载后缓存123456789只加载一次，之后用的存在缓存的值例如：require(&apos;./a&apos;);require(&apos;./a&apos;);这时候会输出一个this is a,而不是两个, 一旦出现某个模块被循环加载，就输出以执行的部分,还未执行的部分不会输出举个例子，在此处建立三个文件123456//06_run.jsconst A = require(&apos;./05_require/a&apos;);//此处因为上面已经引入过了B，所以不会再进行处理，所以此处直接从缓存中取值;const B = require(&apos;./05_require/b&apos;); 此处建立模块 123456789101112131415161718192021//05_require/amodule.exports.test = &apos;这是A&apos;;const B = require(&apos;./b&apos;);console.log(&apos;这是在A里面的引入的B&apos;+B.test);module.exports.test = &apos;这是AA&apos;;//05_require/bmodule.exports.test = &apos;这是B&apos;;const A = require(&apos;./a&apos;);console.log(&apos;这是在B里面的引入的A&apos;+A.test);module.exports.test = &apos;这是BB&apos;; 执行node 06_run之后，我们会发现输出 12这是在B里面的引入的A这是A这是在A里面的引入的B这是BB 这就是require的会遇到的问题，有时候我们深入刨析一个问题，了解他的利弊，好的方面应用，不好的方面避免它，不然，当代码上千行的时候，我们在更改，可能就为时已晚，悔不当初。所以，了解一门语言的深层次的东西，是我们必须要掌握的内容。 4、系统内置模块12345678910111213141516171819202122// 07_run.jsconst fs = require(&apos;fs&apos;);//读文件为异步操作，需要回掉来获取值const nnn = fs.readFile(&apos;./07_fs.js&apos;, (error, data) =&gt; &#123; if(error)&#123; console.log(error) &#125;else&#123; console.log(data) &#125;&#125;)console.log(nnn)//&lt;Buffer 0a 63 6f 6e 73 74 20 66 73 20 3d 20 72 65 71 75 69 72 65 28 27 66 73 27 29 3b 0a 0a 2f 2f e8 af bb e6 96 87 e4 bb b6 e4 b8 ba e5 bc 82 e6 ad a5 e6 93 ... &gt;这是一个16进制的数字fs操作二进制流 当更改为 123456789101112131415const fs = require(&apos;fs&apos;);//读文件为异步操作，需要回掉来获取值const nnn = fs.readFile(&apos;./07_fs.js&apos;, (error, data) =&gt; &#123; if(error)&#123; console.log(error) &#125;else&#123; console.log(data.toString()) &#125;&#125;)console.log(nnn) //输出的就是当前的内容 5、系统外置模块例如引入chalk，颜色模块 123npm init npm install chalk --save-dev 在这里有个注意的点 dependencies： 打包的依赖 devDependencies： 开发的依赖 npm做了一个优化所有的内容，都会放置第一层，而不是全放在文件夹内部，所以我们明明下载了一个chalk,但是却有好几个包，以前会全部放置到chalk内部的node_modules，但是现在不会了。这样就在一级node_modules，否侧依赖太多，会导致node_modules,会非常大 我们可以通过一个命令查看全局安装的地点 1npm root -g 会得到 1/usr/local/lib/node_modules 这里就是我们全局安装的一些内容 6、exports 和 module.exports的区别node中每个模块抛出的其实是module来定义的，exports其实是module.exports 的简写，但是这里我们需要注意的是： 123456789101112131415// 08_require.jsconst v = require(&apos;./08_run&apos;);console.log(v.test);//08_run.jsmodule.exports = &#123; a:1, test: 10,&#125; 如果直接写exports = {} ,这是错误的，为什么呢，因为你改变了他的指向 module.exports 这个的指向是module，而exports = {} ,这个指向不是module了，所以读取不到 7、global浏览器的全局window，node则是global 这里我们重点介绍一下setImmediate 我们先在这里扩展一下知识点： 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 这里可以详细查看这个 https://www.cnblogs.com/c3gen/p/6170504.html 这里setImmediate 和 setTimeout类似，是一个异步的函数，它是进入任务队列，当完成的时候，就会执行它; 8、process进程类似于我们常用的 9、debug]]></content>
  </entry>
  <entry>
    <title><![CDATA[精通webpack之路（1）]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%B2%BE%E9%80%9Awebpack%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先来个序言，从这篇开始，我将重点把webpack作为一个重点，来研究它的核心内容 1、 123456mkdir webpack-demonpm init npm install --save-dev webpack 这里需要注意的点（这里的参数–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。） 至此，我们安装完毕 那么问题就来了 这里的参数–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack 3中hash、chunkhash和contenthash三者的区别]]></title>
    <url>%2F2018%2F06%2F01%2Fwebpack-3%E4%B8%ADhash%E3%80%81chunkhash%E5%92%8Ccontenthash%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[首先在这里祝大家61儿童节快乐，新的一个月开始了，那么作为个人要有一个新的目标，那新的目标是什么呢？ 每天更新一篇博客，扩展横向纵向维度，并且加强深度，祝自己好运吧～！ 好了，那么来开始第一篇内容： 在使用webpack 3中，文件名的hash值可以有三种hash生成方式，那具体使用哪一种呢？ hash如果都使用hash的话，所有文件的hash都是一样的，而且每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效 123456output:&#123; path:path.resolve(__dirname,&apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;[name]-[hash].js&apos;&#125; chunkhash既然hash的用法有这种缺陷，那是否有更好的办法，使只有被修改了的文件的文件名hash值修改呢？答案就是使用chunkhash。 123456output:&#123; path:path.resolve(__dirname,&apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;[name]-[chunkhash].js&apos;&#125; 当然这样做还是有问题，就是如果我一个js文件里面引入了css文件。这时要是我修改了js，但没修改css，能否让css能够继续利用缓存呢？答案是可以！ 首先，我们使用Extract-text-webpack-plugin插件将css文件从js中分离出来。 1234567891011121314&#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &#123; loader:&quot;css-loader&quot;, options:&#123; minimize: true //css压缩 &#125; &#125; &#125;)&#125; 然后设置css的plugin 1234new ExtractTextPlugin(&#123; filename: &apos;css/[name]-[chunkhash].css&apos;,&#125;), contenthash对css使用了chunkhash之后，我们测试会发现，如果修改了js直接，css文件名的hash值确实没变，但这时要是我们修改css文件的话，我们就会发现css文件名的hash值居然没变化，这样就导致我们的非覆盖发布css文件失效了。所以这里需要注意就是css文件必须使用contenthash。将上面的css插件配置改为如下： 1234new ExtractTextPlugin(&#123; filename: &apos;css/[name]-[contenthash].css&apos;,&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[js判断类型的一些方法]]></title>
    <url>%2F2018%2F05%2F29%2Fjs%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[如何判断是对象还是数组1.对于Javascript 1.8.5（ECMAScript 5），变量名字.isArray( )可以实现这个目的 12345678var a = []var b = &#123;&#125;Array.isArray(a);//trueArray.isArray(b)//false 2.调用toString( )方法试着将该变量转化为代表其类型的string。 12345678var a = []var b = &#123;&#125;Object.prototype.toString.call(a) === &apos;[object Array]&apos;//trueObject.prototype.toString.call(b) === &apos;[object Array]&apos;//false 伪数组变为数组先来说一下什么是伪数组 具有length属性； 按索引方式存储数据； 不具有数组的push()、pop()等方法； 1、 123456var fakeArray01 = &#123;0:&apos;a&apos;,1:&apos;b&apos;,length:2&#125;;//这是一个标准的伪数组对象 var arr01 = Array.prototype.slice.call(fakeArray01); alert(arr01[0]);//a 2、1234567891011function one () &#123; console.log(arguments) //伪数组 //Arguments(3) [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ] return Array.prototype.slice.call(arguments)&#125;console.log(one(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;))// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈js闭包]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[现在发展到现在，其实闭包被很多人提及，但是因为很多人其实都没有理解很透，所以阐述会有些问题。那现在让我们一起帮大家彻底理解闭包 从三部分来理解一下 闭包是一种特殊的对象 他有两部分组成，执行上下文（代号A）,以及在该执行上下文中创建的函数（代号B） 当B执行时，如果访问了A中的变量对象中的值，那么闭包就会产生 了解了这三个重要的概念，那么恭喜你，离进一步掌握不远了 干说不行，必须来个例子 demo1 12345678910function foo () &#123; let a = 20 let b = 30 function bar() &#123; return a + b &#125; return bar&#125;let bar = foo()bar() 让我们来看看在具体的浏览器中的模式 来扩展一下上面的知识点： Call Stack: 当前函数的调用栈 Scope: 当前正在被执行函数的作用域链 Local: 当前活动对象 Closure: 闭包（在谷歌中以当前执行上下文A的函数名代指闭包，此时，我们可以看到B访问了A中的两个变量） 此处一定要结合上面的三个部分理解来看 在这里我在给大家来两个例子，你就会对这个更加深刻了 第一个例子 12345678910111213141516let name = &apos;zhangsan&apos;let obj = &#123; name : &apos;lisi&apos;, getName: function () &#123; return function () &#123; return this.name &#125; &#125;&#125;let n = obj.getName()let _name = n.call(obj) 第二个例子 1234567891011121314151617let name = &apos;zhangsan&apos;let obj = &#123; name : &apos;lisi&apos;, getName: function () &#123; let self = this return function () &#123; return self.name &#125; &#125;&#125;let n = obj.getName()let _name = n()]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于CSS 布局的一些问题]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%85%B3%E4%BA%8ECSS-%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[作为前端，css经典布局是我们必备的理论知识，不论是在工作中还是面试中都是经常会被提及的点，那么我们来总结一下。 CSS水平垂直居中的几种方法1、margin:auto法 1234&lt;div&gt; &lt;img src="xx.png"&gt;&lt;/div&gt; 12345678910111213141516div&#123; width: 300px; height: 300px; position: relative; border: 1px solid #465468;&#125;img&#123; position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0;&#125; 2、负margin法 1234&lt;div class="container"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.container&#123; width: 500px; height: 400px; border: 2px solid #379; position: relative;&#125;.inner&#123; width: 480px; height: 380px; background-color: #746; position: absolute; top: 50%; left: 50%; margin-top: -190px; /*height的一半*/ margin-left: -240px; /*width的一半*/&#125; 3、弹性盒子法 123456&lt;div class="container"&gt; &lt;div class="inner"&gt; 我在容器中水平垂直居中 &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.container&#123; width: 300px; height: 200px; border: 3px solid #546461; display: flex; /*align-items属性定义项目在交叉轴上如何对齐。center:交叉轴的中点对齐。*/ align-items: center; /*justify-content属性定义了项目在主轴上的对齐方式。center： 居中*/ justify-content: center;&#125;.inner&#123; border: 3px solid #458761; padding: 20px;&#125;.inner&#123; border: 3px solid #458761; padding: 20px;&#125; 接下来说说css布局来说说常用的两大方法：圣杯布局和双飞燕布局 圣杯布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Object&lt;/title&gt; &lt;style type="text/css"&gt; #main &#123; overflow: hidden; /*修整由子元素浮动引起的高度塌陷问题*/ zoom: 1;/*低版本ie下:触发haslayout属性,修整由子元素浮动引起的高度塌陷问题*/ /*将主体部分左右侧预留出左右边栏大小的空白位置*/ padding: 0 300px 0 220px; &#125; .m_content, .m_leftside, .m_rightside &#123; float: left; /*目的是将左右侧边栏拉回*/ position: relative; &#125; .m_content &#123; width: 100%; background: #ccc; &#125; .m_leftside &#123; width: 220px; /*由于m_content占据了100%空间，所以需要用负的margin值将左边栏拉回*/ margin-left: -100%; /*将主体部分预留的左侧补白区域填充满*/ left: -220px; background: #ddd; &#125; .m_rightside &#123; width: 300px; /*用负的margin值将右边栏拉回自身大小个像素单位*/ margin-left: -300px; /*将主体部分预留的右侧补白区域填充满*/ left: 300px; background: #ededed; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div class="m_content"&gt;这里是主体&lt;/div&gt; &lt;div class="m_leftside"&gt;这是左侧边栏&lt;/div&gt; &lt;div class="m_rightside"&gt;这是右侧边栏&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 来看看效果 以上就是圣杯布局方法，基本思路是运用浮动加定位的方法，缺点是代码较复杂，不能模拟三栏等高效果。 双飞燕布局布局的效果跟圣杯的一样，代码有所不同。双飞燕布局的代码更加简单，只是多加了一个div用来布局。基础布局部分代码一样。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Object&lt;/title&gt; &lt;style type="text/css"&gt; #main &#123;overflow: hidden;zoom: 1;&#125;/*这里不需要加padding了*/ .m_content, .m_leftside, .m_rightside &#123;float: left;&#125; .m_content &#123; width: 100%; &#125; /*用左右边距将左右边栏的位置预留出来*/ .m_c_wrap &#123; margin-left: 220px; margin-right:300px; &#125; .m_leftside &#123; width: 220px; margin-left: -100%; &#125; .m_rightside &#123; width: 300px; margin-left: -300px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div class="m_content"&gt; &lt;!--正真的主体开始--&gt; &lt;div class="m_c_wrap"&gt;这里是主体&lt;/div&gt; &lt;/div&gt; &lt;div class="m_leftside"&gt;这是左侧边栏&lt;/div&gt; &lt;div class="m_rightside"&gt;这是右侧边栏&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 了解了以上两种布局的方法后，很多布局都能写得得心应手了。但是应对多栏等高布局还有点欠缺。那么现在来谈谈多栏等高布局的方法。 这里详细总结了等高布局的八大方 👉 http://www.w3cplus.com/css/creaet-equal-height-columns]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入vue如何实现双向绑定]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%B7%B1%E5%85%A5vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[重点想说说这个Object.definePropertyvue.js是通过它实现双向绑定的 官方的定义 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 语法 Object.defineProperty(obj,prop,descriptor) 参数 obj 需要定义属性的对象。 prop 需定义或修改的属性的名字。 descriptor 将被定义或修改的属性的描述符。 返回值 返回传入函数的对象，即第一个参数obj 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。 详情可以查看 👉 https://www.jianshu.com/p/07ba2b0c8fca 视图和数据变化绑定12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Object&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;你好，&lt;span id='nickName'&gt;&lt;/span&gt;&lt;/p&gt; &lt;div id="introduce"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //视图控制器 var userInfo = &#123;&#125;; Object.defineProperty(userInfo, "nickName", &#123; get: function()&#123; return document.getElementById('nickName').innerHTML; &#125;, set: function(nick)&#123; document.getElementById('nickName').innerHTML = nick; &#125; &#125;); Object.defineProperty(userInfo, "introduce", &#123; get: function()&#123; return document.getElementById('introduce').innerHTML; &#125;, set: function(introduce)&#123; document.getElementById('introduce').innerHTML = introduce; &#125; &#125;) userInfo.nickName = "张三"; userInfo.introduce = "北京" &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[来细细探讨一下vue如何优化seo]]></title>
    <url>%2F2018%2F05%2F24%2F%E6%9D%A5%E7%BB%86%E7%BB%86%E6%8E%A2%E8%AE%A8%E4%B8%80%E4%B8%8Bvue%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96seo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mac安装nginx]]></title>
    <url>%2F2018%2F05%2F24%2Fmac%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[首先在你的终端上输入brew 1234567891011121314151617181920212223Example usage: brew search [TEXT|/REGEX/] brew info [FORMULA...] brew install FORMULA... brew update brew upgrade [FORMULA...] brew uninstall FORMULA... brew list [FORMULA...]Troubleshooting: brew config brew doctor brew install --verbose --debug FORMULAContributing: brew create [URL [--no-fetch]] brew edit [FORMULA...]Further help: brew commands brew help [COMMAND] man brew https://docs.brew.sh 如果是这玩意恭喜你，可以直接安装了 如果提示是 1-bash: brew: command not found 那么需要进行安装 可以移步查看brew的官网👉https://brew.sh/index_zh-cn 很多人可能不了解 Homebrew, 其实它相当于开发软件界的 Appstore. 比如,如果我要安装 python 的最新版本,那么传统的做法是 1 到官方网站下载 python 的最新版本 2 极其麻烦和小心翼翼的删除自带的 python 版本 3 安装新的版本 4 设置环境变量 而借助 Homebrew, 需要做的仅仅是:brew uninstall pythonbrew install python 整个过程只是等待而已,不需要百度 python 的官方网址,不需要找卸载安装配置环境变量教程… 如何安装brew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 注意： 因网络的原因,可能会不成功,请多尝试几次,一直到成功安装. 中间会出现一个 Press RETURN to continue or any other key to abort,【请及时回车,并输入密码】 当结尾出现 1234==&gt; Next steps:- Run `brew help` to get started- Further documentation: https://docs.brew.sh 可以在输入brew进行查看，如果为开头说提示的内容，恭喜你安装成功💥💥 那么接下里看nginx不要输入 1sudo brew install nginx 会提示 12345Error: Running Homebrew as root is extremely dangerous and no longer supported.As Homebrew does not drop privileges on installation you would be giving allbuild scripts full access to your system.bogon:~ jiwei$ brew install nginxUpdating Homebrew... 直接输入 1brew install nginx 安装完成 输入 1nginx -v 会提示版本号 1nginx version: nginx/1.13.12 启动nginx 输入 http://localhost:8080， 这里告诉大家几个常见的命令 启动 nginx1nginx 关闭nginx1nginx -s stop 重新加载nginx【例如你修改了nginx的配置，需要这个命令来让你的内容生效】1sudo nginx -s reload 到此你的mac上就有了nginx 扩展个内容在这需要了解的几个路径 1、 1/usr/local/etc/nginx 这个文件下的nginx.conf，可以进行一些配置。 2、 1/usr/local/Cellar/nginx/1.13.12/html 这是放置静态资源的内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[在vue中使用sass的配置的方法]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8sass%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、创建一个基于 webpack 模板的新项目1vue init webpack myvue 2、在当前目录下，安装依赖123cd myvuenpm install 3、安装sass的依赖包123npm install --save-dev sass-loader//sass-loader依赖于node-sassnpm install --save-dev node-sass 4、在build文件夹下的webpack.base.conf.js的rules里面添加配置1234&#123; test: /\.scss$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;]&#125; 5、在APP.vue中修改style标签]]></content>
  </entry>
  <entry>
    <title><![CDATA[git实际开发遇到的问题以及解决方式]]></title>
    <url>%2F2018%2F05%2F18%2Fgit%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在实际工作当中，我们会遇到git的一些问题，总结了一些解决方法 1、git 如何把远程分支搞下来当我想从远程仓库里拉取一条本地不存在的分支时 git checkout -b 本地分支名 origin/远程分支名 如果出现提示： 12fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit? 表示拉取不成功。我们需要先执行 git fetch 然后再执行 git checkout -b 本地分支名 origin/远程分支名 即可。 2、本地检出一个新的分支并推送到远程仓库 创建本地分支 git checkout -b 新分支名 执行该指令后，会在本地创建一个新分支，该分支是从当前分支上检出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。 比如我要创建一个名为dev1的新分支： 此时，再执行git branch查看当前本地所有分支，就会看到两个分支：master与dev1. 推送本地分支到远程仓库 git push –set-upstream origin 分支名]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入了解跨域问题，以及解决的方式]]></title>
    <url>%2F2018%2F05%2F09%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事 跨域的含义跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com 页面去请求 www.google.com 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域 为什么浏览器要限制跨域访问呢？原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题： 用户访问www.mybank.com ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器 用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 www.xiee.com 这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对www.mybank.com 的操作。 如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。 如何解决跨域看到这，我要吐个槽，在我以前面试的经历当中，有一位年轻的面试官，问了我一个问题，怎么解决跨域，我说通过nginx反向代理，他跟我说，没用过jsonp么，那个表情，好比再说，你连jsonp都不知道么。所以说，技术面试，一般不仅仅是对面试者的考验，更是面的人的一种考验。 继续咱们的！！！ 不知道同学们有木有用过vue-cli脚手架，在config/index.js中有一段本地开发如何解决跨域的代码 123456789proxyTable: &#123; &apos;/apis&apos;: &#123; target: &apos;http://xxx/&apos;, changeOrigin: true, pathRewrite: &#123; &apos;^/apis&apos;: &apos;&apos; &#125; &#125;&#125;, 首先让我们来看看这个东西实现的原理， 他依赖的是http-proxy-middleware，了解它的自行百度 这段代码的意思就是，本地反向代理。此原理同样应用到服务器端，在nginx上，配置一个 1234location ^~/apis/&#123; rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://xxx/;&#125; 以下做一个解释 1.’^~ /apis/ ‘ 这是是一个匹配规则，用于拦截请求，匹配任何以 /apis/开头的地址，匹配符合以后，停止往下搜索正则。 2.rewrite ^/apis/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 * break代表匹配一个之后停止匹配。 3.proxy_pass 既是把请求代理到其他主机，其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下: 不带/ 123location /apis/&#123; proxy_pass http://b.com:8300; &#125; 带/ 123location /apis/ &#123; proxy_pass http://b.com:8300/; &#125; 上面两种配置，区别只在于proxy_pass转发的路径后是否带 “/”。 针对情况1，如果访问url = http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/ 作为根路径，请求test/路径下的资源。 针对情况2，如果访问url = http://server/apis/test.jsp，则被nginx代理后，请求路径会变为 http://proxy_pass/test.jsp，直接访问server的根资源。 修改配置后重启nginx代理就成功了。 至此，我们的跨域问题配置大功告成。 有什么疑问，可以上github，有我的练习方式，欢迎大家指正。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用nuxt]]></title>
    <url>%2F2018%2F05%2F07%2F%E4%BD%BF%E7%94%A8nuxt%2F</url>
    <content type="text"><![CDATA[关于nuxt，我在这里就不过多介绍了 https://zh.nuxtjs.org/ 大家可以自行查看]]></content>
  </entry>
  <entry>
    <title><![CDATA[手把手教你撸electron]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%92%B8electron%2F</url>
    <content type="text"><![CDATA[electron 就不多介绍了，大家可以自行百度查看。 那么接下来，结合我实际的经验教大家如何快速的搭建一个自己的electron案例 我们使用的是https://github.com/SimulatedGREG/electron-vue 大家可以自行查看 12345678npm install -g vue-clivue init simulatedgreg/electron-vue my-projectcd my-projectnpm install 在这里安装的时候会咨询你选择 electron-builder和electron-packager 个人建议 electron-builder]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？]]></title>
    <url>%2F2018%2F05%2F05%2F%E4%BD%BF%E7%94%A8Vuejs-Vue-router-%E5%BC%80%E5%8F%91%E5%8D%95%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%E6%97%B6%E8%83%BD%E9%94%80%E6%AF%81%E5%8E%9F%E7%BB%84%E4%BB%B6%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[问题：(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？描述: 我有一个单页面应用，有页面A和页面B，二者是同级组件，关系是这样的： 12345678router.map(&#123;&apos;/a&apos;: &#123; component: A&#125;,&apos;/b&apos;: &#123; component: B&#125;, 例如，第一次打开时，显示页面 A，页面 A 有一个setInterval事件，每隔一秒钟会向后台发送一个Ajax请求。这时我点击页面 A 上的跳转按钮，跳到页面 B，通过观察网络连接，发现页面 A 上的Ajax请求仍然在继续。 请问应当进行什么样的设置，才能使得页面切换时，原来的组件就被销毁？ 这是个非常严重的问题，同级组件绑定的事件，还会在另一个组件里继续监听。所以我猜想会有简单的配置方法，但我看遍了 Vue 的文档和 Vue-router 的文档，也未发现相关配置。 参考文档： http://vuejs.github.io/vue-router/zh-cn/options.html http://vuejs.org/guide/ 解决方案1: 1、setInterval事件和组件的生命周期没有直接关系。2、setInterval会返回一个ID 值。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 解决方案2: router切换时，原来的组件确实已经销毁了，你可以看到ready生命周期函数是每次都触发了的。你这里的问题不在于组件是否销毁，因为setInterval事件本身和组件没有关系。 setInterval相当于该组件申请的一种资源，在使用该组件时获取，在离开该组件时释放。这个过程只能是你手动进行的。所以你应该在离开该组件时，比如route的deactivate或者beforeDestory生命周期函数里手动clearInterval。 其实很多框架里都是这样，比如桌面程序中某个窗口初始化时需要打开数据库连接（我们也可以视为一种资源），当窗口关闭时，程序本身并不知道“打开数据库连接”的反向操作是什么。所以我们需要在窗口销毁的回调方法里手动去释放这个资源，去写断开连接的代码。 解决方案3: http://stackoverflow.com/questions/35104770/how-to-destroy-a-component-when-building-spa-with-vue-js-and-vue-router http://vuejs.github.io/vue-router/zh-cn/pipeline/deactivate.html 以上介绍了“(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？”的问题解答，希望对有需要的网友有所帮助。本文网址链接：http://www.codes51.com/itwd/1037580.html 最后我根据解决方案1解决了，贴下我的代码： 1234567891011121314created () &#123; this.n = setInterval(() =&gt; &#123; //... &#125;, 20000) this.n1 = setInterval(() =&gt; &#123; //... &#125;, 60000)&#125;,beforeDestroy () &#123; clearInterval(this.n) clearInterval(this.n1)&#125;,]]></content>
  </entry>
  <entry>
    <title><![CDATA[elementui中el-upload自定义上传方法中遇到的问题]]></title>
    <url>%2F2018%2F05%2F04%2Felementui%E4%B8%ADel-upload%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。12345678910111213141516&lt;el-upload class="upload-demo" ref="upload" action="http://127.0.0.1:5000/json/import" :http-request="myUpload" :on-preview="handlePreview" :on-remove="handleRemove" :on-error="handleError" :on-success="handleSuccess" :file-list="fileList" :auto-upload="false"&gt; &lt;el-button slot="trigger" size="small" type="primary"&gt;选取文件&lt;/el-button&gt; &lt;el-button style="margin-left: 10px;" size="small" type="success" @click="submitUpload"&gt;上传到服务器&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;只能上传json文件，且不超过500kb&lt;/div&gt;&lt;/el-upload&gt; 12345678910111213141516171819202122232425myUpload(content) &#123; console.log(‘myUpload...‘); this.$axios(&#123; method: ‘post‘, url: content.action, timeout: 20000, data: content.file &#125;).then(res =&gt; &#123; content.onSuccess(‘配时文件上传成功‘) &#125;).catch(error =&gt; &#123; if (error.response) &#123; // The request was made and the server responded with a status code // that falls out of the range of 2xx content.onError(‘配时文件上传失败(‘ + error.response.status + ‘)，‘ + error.response.data); &#125; else if (error.request) &#123; // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js content.onError(‘配时文件上传失败，服务器端无响应‘); &#125; else &#123; // Something happened in setting up the request that triggered an Error content.onError(‘配时文件上传失败，请求封装失败‘); &#125; &#125;); &#125; 这种方式很常见，唯一要注意的点是在上传方法调用后判断结果成功或者失败的时候，需要回调el-upload控件的onSuccess和onError方法，为的是能够复用el-upload原生的一些动作，比如如果成功了，页面上的文件列表会有一个绿勾标记上传成功的文件，如果失败则会把失败的文件从文件列表中删除，如果不回调是没有这些功能的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cordova安装及使用之android篇]]></title>
    <url>%2F2018%2F04%2F28%2Fcordova%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B9%8Bandroid%E7%AF%87%2F</url>
    <content type="text"><![CDATA[机型：mac本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本纯属个人瞎搞，如果有不对的地方欢迎指正先进入正题，使用此cordova首先是配备java环境，然后安装android-sdk 一、安装jdk以及环境变量 MAC系统安装JDK1.8及环境变量配置 👉 https://blog.csdn.net/deliciousion/article/details/78046007 下载：jdk下载 👉 http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mac设置安卓sdk环境变量 👉 https://blog.csdn.net/free_co/article/details/77115920 以下是我的配置 设置JAVA_HOME环境变量，指定为JDK安装路径设置ANDROID_HOME环境变量，指定为Android SDK安装路径同时也建议你添加Android SDK的tools和platform-tools目录到你的PATH 123export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Homeexport ANDROID_HOME=/Users/你的用户名/library/Android/sdkexport PATH=$&#123;PATH&#125;:/Users/你的用户名/library/Android/sdk/platform-tools:/Users/你的用户名/library/Android/sdk/tool]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何查看页面是否开启了gzip压缩]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86gzip%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。既然如此，让我们从以下几个方面说起HTTP 协议中的 Content-EncodingAccept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。 工作原理： 1、浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表； 2、服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式； 3、浏览器拿到响应正文后，依据 Content-Encoding 进行解压。 4、当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。 【内容编码】目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过 gzip 压缩过的文本响应，只有原始大小的 1/4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于 JPG / PNG 这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费 CPU。 DEFLATE、ZLIB、GZIP 这种大写字符，表示数据压缩格式； deflate、gzip 这种小写字符，表示 HTTP 中 Content-Encoding 的取值； Gzip 特指 GUN zip 文件压缩程序，Zlib 特指 Zlib 库； nginx配置这个详细内容请查看这个 👉 （Nginx配置详解）https://www.cnblogs.com/brant/p/7209048.html 详解gzipgzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分； Gzip压缩传输能更加有效节约带宽流量。他先把文本压缩为.gz然后传输给浏览器，最后由浏览器负责解压缩呈现给用户。 老版本的浏览器可能不能显示，但是现在大多数浏览器都能显示。 如何查看是否开启gizp先来看看开启的请求 再来看看没开启的请求 看到这个就可以给你的小伙伴说了，看吧，人家的开启了，你没开启，自己研究研究吧！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[小程序api封装]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%B0%8F%E7%A8%8B%E5%BA%8Fapi%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[微信小程序如今很火热🔥，尤其对于开发者来说，支持的越来越好。例如美团的框架mpvue的推出更是让小程序的开发表的高效。 mpvue传送门 👉http://mpvue.com/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var API_URL = &quot;http://xxx&quot;//请求var requestHandler = &#123; url: &apos;&apos;, params:&#123;&#125;, success: function(res)&#123; // success &#125;, fail: function() &#123; // fail &#125;, complete: function () &#123; &#125;,&#125;//接口统一状态码var code = &#123; &quot;success&quot;: 1, &quot;fail&quot;: 0&#125;//GET请求function GET(requestHandler) &#123; request(&apos;GET&apos;,requestHandler)&#125;//POST请求function POST(requestHandler) &#123; request(&apos;POST&apos;,requestHandler)&#125;function request(method,requestHandler) &#123; //注意：可以对params加密等处理 var params = requestHandler.params; wx.request(&#123; //默认为API_URL，当输入url变更为https://XXX 以url变化的为主 url: /^\s*http\s*/gi.test(requestHandler.url) ? requestHandler.url : API_URL + requestHandler.url, data: params, method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT header: &#123; // 设置请求的 header &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;, success: function(res)&#123; //注意：可以对参数解密等处理 //requestHandler.success() if (res.data &amp;&amp; res.data.code == code.success)&#123; requestHandler.success &amp;&amp; requestHandler.success(res.data); &#125;else&#123; wx.showModal(&#123; title: &apos;数据加载失败&apos;, content: res.data.message || &apos;服务异常，请稍后重试~&apos;, &#125;); &#125; &#125;, fail: function() &#123; requestHandler.fail() &#125;, complete: function() &#123; // complete requestHandler.complete() &#125; &#125;)&#125;module.exports = &#123; GET: GET, POST: POST&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数式编程和面向对象编程的区别和优劣]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%A3%2F</url>
    <content type="text"><![CDATA[一、先来看一下两者的定义 【函数式编程】顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。这种编程最重要的基础是λ演算，接受函数当作输入和输出。 【面向对象编程】这种编程是把问题看作由对象的属性与对象所进行的行为组成。基于对象的概念，以类作为对象的模板，把类和继承作为构造机制，以对象为中心，来思考并解决问题。 二、优点 【函数式编程】支持闭包和高阶函数，闭包是一种可以起函数的作用并可以如对象般操作的对象；而高阶函数是可以以另一个函数作为输入值来进行编程。支持惰性计算，这就可以在求值需要表达式的值得时候进行计算，而不是固定在变量时计算。还有就是可以用递归作为控制流程。函数式编程所编程出来的代码相对而言少很多，而且更加简洁明了。 【面向对象编程】面向对象有三个主要特征，分别是封装性、继承性和多态性。类的说明展现了封装性，类作为对象的模板，含有私有数据和公有数据，封装性能使数据更加安全依赖的就是类的特性，使得用户只能看到对象的外在特性，不能看到对象的内在属性，用户只能访问公有数据不能直接访问到私有数据。类的派生功能展现了继承性，继承性是子类共享父类的机制，但是由于封装性，继承性也只限于公有数据的继承（还有保护数据的继承），子类在继承的同时还可以进行派生。而多态性是指对象根据接收的信息作出的行为的多态，不同对象接收同一信息会形成多种行为。 三、缺点 【函数式编程】所有的数据都是不可以改变的，严重占据运行资源，导致运行速度也不够快。 【面向对象编程】为了编写可以重用的代码导致许多无用代码的产生，并且许多人为了面向对象而面向对象导致代码给后期维护带来很多麻烦。 四、理解 【函数式编程】 函数是”第一等公民” 只用”表达式”，不用”语句” 没有”副作用” 不修改状态（由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。） 引用透明 代码简洁，开发快速 接近自然语言，易于理解 更方便的代码管理 易于”并发编程” 【面向对象编程】 实例化其实就是把构造函数变成一个对象，但是如果多个新建对象被实例化的时候，其实等于构造函数不断被复制占大量的内存，故对一些需要不对被实例化的构造函数，不适合放太多属性在里面。这个时候就需要用到原型（prototype） 对象继承分两种情况，一种是构造函数的继承，一种是原型（prototype）的继承： 拷贝继承-我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗]]></content>
  </entry>
  <entry>
    <title><![CDATA[arguments的那些事]]></title>
    <url>%2F2018%2F04%2F25%2Farguments%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[arguments 定义: arguments 是一个对应于传递给函数的参数的类数组对象。 有几个比较重要的知识点是应该注意的 arguments对象是所有（非箭头）函数中都可用的局部变量。 你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们 123arguments[0]arguments[1]arguments[2] 参数可以被设置 1arguments[1] = &apos;new value&apos;; arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array： 12345var args = Array.prototype.slice.call(arguments);var args = [].slice.call(arguments);// ES2015const args = Array.from(arguments); 对参数使用扩展语法 您还可以使用Array.from()方法或扩展运算符将参数转换为真实数组： 12var args = Array.from(arguments);var args = [...arguments];]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript中的apply和call]]></title>
    <url>%2F2018%2F04%2F24%2Fjavascript%E4%B8%AD%E7%9A%84apply%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[今天深入理解一下js中的这个点 apply：方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function（args–&gt;arguments） 来个例子可以更好的理解 eg : 1234567891011121314function Parent (name,age) &#123; this.name = name this.age = age&#125;function Children (name,age,className) &#123; Parent.apply(this,arguments) this.className = className &#125;let p = new Children(1,2,3)//p =&gt; Children &#123;name: 1, age: 2, className: 3&#125; 如果你看到 arguments有点懵逼，请查看我的另一个文章可查看我的另一篇内容call：和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]]) obj：这个对象将代替Function类里this对象 params：这个是一个参数列表 eg: 1234567891011121314function Parent (name,age) &#123; this.name = name this.age = age&#125;function Children (name,age,className) &#123; Parent.call(this,name,age) this.className = className &#125;let p = new Children(1,2,3)//p =&gt; Children &#123;name: 1, age: 2, className: 3&#125; apply和call 应用场景 在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Parent的时候参数的列表是对应一致的(也就是Parent和Children的参数列表前两位是一致的) 就可以采用 apply 如果我的Parent的参数列表是这样的(age,name),而Children的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Parent.call(this,age,name,grade)) apply的巧妙用法这个就是apply的一个巧妙的用处,可以将一个数组默认的转换为一个参数列表([param1,param2,param3] 转换为 param1,param2,param3) 这个如果让我们用程序来实现将数组的每一个项,来装换为参数的列表,可能都得费一会功夫,借助apply的这点特性,所以就有了以下高效率的方法: Math.max 可以实现得到数组中最大的一项 123456let arr = [1,2,3,5]let n = Math.max.apply(null ,arr)// n 5 数组合并 再比如数组的push方法 var arr1=[1,3,4] var arr2=[3,4,5] 如果我们要把 arr2展开，然后一个一个追加到 arr1中去，最后让 arr1=[1,3,4,3,4,5] arr1.push(arr2) 显然是不行的。 因为这样做会得到 [1,3,4, [3,4,5] ] 我们只能用一个循环去一个一个的push (当然也可以用 arr1.concat(arr2) 但是concat方法并不改变 arr1本身) 1234567var arrLen=arr2.lengthfor(var i=0;i&lt;arrLen;i++)&#123; arr1.push(arr2[i])&#125; 自从有了 Apply ,事情就变得如此简单 Array.prototype.push.apply(arr1,arr2) 点滴汇聚能量!]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于svg-sprite-loader]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%85%B3%E4%BA%8Esvg-sprite-loader%2F</url>
    <content type="text"><![CDATA[现在我们要接触的是一个叫 svg-sprite-loader 的插件，用来根据导入的 svg 文件自动生成 symbol 标签并插入 html，接下来就可以在模版中方便地使用 svg-sprite 技术了 如果不知道 svg-sprite 是什么，目前，SVG Sprite最佳实践是使用symbol元素。symbol元素是什么呢？单纯翻译的话，是“符号”的意思。然，这个释义并不符合这里的场景。不知大家有没有用过Flash，symbol实际上就类似于Flash中的“影片剪辑”、或者“元件”。 因此，我个人觉得，symbol应该解释为“元件”最为恰当！ 那，symbol和SVG Sprite又有什么关系呢？ 我们可以把SVG元素看成一个舞台，而symbol则是舞台上一个一个组装好的元件，这这些一个一个的元件就是我们即将使用的一个一个SVG图标。 使用svg-sprite的好处 页面代码清爽 随处重复调用 每个 SVG 图标都可以更改大小颜色 结合vue-cli项目来简单说下 1 创建组件 SvgIcon123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;svg-icon&apos;, props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return &apos;svg-icon &apos; + this.className &#125; else &#123; return &apos;svg-icon&apos; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 2 src目录下创建icon目录结构为 icon/svg 此处放置svg图片 icon/index.js 123456789import Vue from &apos;vue&apos;import SvgIcon from &apos;@/components/SvgIcon&apos;// svg组件// register globallyVue.component(&apos;svg-icon&apos;, SvgIcon)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(&apos;./svg&apos;, false, /\.svg$/)requireAll(req) 此处多补充一下扩展知识点 require.context可以使用 require.context() 方法来创建自己的（模块）上下文，这个方法有 3 个参数： 要搜索的文件夹目录 是否还应该搜索它的子目录 以及一个匹配文件的正则表达式 require.context模块导出（返回）一个（require）函数，这个函数可以接收一个参数：request 函数–这里的 request 应该是指在 require() 语句中的表达式导出的方法有 3 个属性： resolve, keys, id。 resolve 是一个函数，它返回请求被解析后得到的模块 id。keys 也是一个函数，它返回一个数组，由所有可能被上下文模块处理的请求组成。id 是上下文模块里面所包含的模块 id. 它可能在你使用 module.hot.accept 的时候被用到 eg：12345678require.context(&quot;./test&quot;, false, /\.test\.js$/);//（创建了）一个包含了 test 文件夹（不包含子目录）下面的、所有文件名以 `.test.js` 结尾的、能被 require 请求到的文件的上下文。require.context(&quot;../&quot;, true, /\.stories\.js$/);////（创建了）一个包含了父级文件夹（包含子目录）下面，所有文件名以 `.stories.js` 结尾的文件的上下文。 3 webpack.base.conf中配置如下：123456789101112131415161718&#123; test: /\.svg$/, loader: &apos;svg-sprite-loader&apos;, include: [resolve(&apos;src/icons&apos;)], options: &#123; symbolId: &apos;icon-[name]&apos; &#125;&#125;,&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: &apos;url-loader&apos;, exclude: [resolve(&apos;src/icons&apos;)], options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125;&#125;, 发现不同了没 include 引入 src/iconsexclude 排除 src/icons 不写exclude就会报错，因为它将svg处理了否侧此处会报错 引用 1&lt;svg-icon icon-class="user" /&gt; 大功告成！ 当你想定义颜色时，通过定义class,直接定义样式 很完美有么有]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-devtools安装的问题以及解决的方式]]></title>
    <url>%2F2018%2F04%2F21%2Fvue-devtools%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[换了一个电脑，安装vue-devtools，因为以前安装过一次，没当回事。结果打脸了，搞了半天才安装好 报错，提示了不识别build/hook.js” 这是什么鬼 结果发现，这是模式应用的错误，更改为development就OK了 更改两处，然后就可以安装了 第一处manifest.json 第二处webpack.config.js 这里的production更改为development 看到这里，然后在执行npm run build 然后在浏览器中扩展程序就好了 这样就ok了]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何做一个带有毛玻璃效果的css样式]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E7%9A%84css%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先来看看毛玻璃效果 再来看看没有毛玻璃的效果 效果很明显有木有让我们来看看如何实现 以下是我写的一段代码，你可以直接copy到你的编辑器，查看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box&#123; height: 300px; width: 300px; border: 1px solid #ccc; position: relative; background: url(http://img.ivsky.com/img/tupian/slides/201803/15/fangsuo_shudian.jpg) no-repeat center center; &#125; .box_inner&#123; position: absolute; height: 100px; width: 100px; overflow: hidden; left: 50%; top: 50%; transform: translate(-50%,-50%); &#125; .img_inner&#123; height: 100px; width: 100px; filter: blur(5px); background: url(http://img.ivsky.com/img/tupian/slides/201803/15/fangsuo_shudian.jpg) no-repeat center center; &#125; .text_inner&#123; height: 100px; width: 100px; position: absolute; z-index: 99; text-align: center; color: #ffffff; left: 0px; top: 0px; line-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='box'&gt; &lt;div class="box_inner"&gt; &lt;div class="img_inner"&gt;&lt;/div&gt; &lt;div class="text_inner"&gt;文字&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-cli无法在打开ip，并且一个局域网下无法在手机调试]]></title>
    <url>%2F2018%2F04%2F20%2Fvue-cli%E6%97%A0%E6%B3%95%E5%9C%A8%E6%89%93%E5%BC%80ip%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%80%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E6%97%A0%E6%B3%95%E5%9C%A8%E6%89%8B%E6%9C%BA%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[无法打开ip查看当我们npm run dev之后，输入localhost没有任何问题，但是当我们输入本机ip就会发现，局域网受限。 这是因为在config/index.js 文件下 host的配置为’localhost’ 当你启动服务之后，也为了自己的项目不让别人通过ip来查看。 如果你想启用ip来查看，那么我们可以有两种方式处理 第一种 config/index.js 文件下 更改host的配置为’0.0.0.0’ 第二种 package.json 文件下 dev 增加 –host 0.0.0.0 配置以上两种任何一种方式，就可以通过ip来访问了。同一个局域网电脑，也可以通过ip来访问。 当我完成以上配置后，信心满满准备在移动端访问，结果，又是受限 崩溃啊！！！ 继续查看文件，此时我查看的是， config/index.js 因为这个是配置的整体内容 此时，一段代码引起了我的注意 devtool: ‘cheap-module-eval-source-map’ 此时，我们扩展一下内容 webpack sourcemap 选项多种模式的一些解释有人说 Webpack 难用，原因是 sourcemap 有 7 种，咱们就尝试解释下这些选项都是什么意思，不仅如此，咱们还会分析如何用最好的姿势使用这些配置。 eval 文档上解释的很明白，每个模块都封装到 eval 包裹起来，并在后面添加 //# sourceURL source-map 这是最原始的 source-map 实现方式，其实现是打包代码同时创建一个新的 sourcemap 文件， 并在打包文件的末尾添加 //# sourceURL 注释行告诉 JS 引擎文件在哪儿 hidden-source-map 文档上也说了，就是 soucremap 但没注释，没注释怎么找文件呢？貌似只能靠后缀，譬如 xxx/bundle.js 文件，某些引擎会尝试去找 xxx/bundle.js.map inline-source-map 为每一个文件添加 sourcemap 的 DataUrl，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 DataUrl 是包含一个文件完整 souremap 信息的 Base64 格式化后的字符串，而不是一个 url。 eval-source-map 这个就是把 eval 的 sourceURL 换成了完整 souremap 信息的 DataUrl cheap-source-map 不包含列信息，不包含 loader 的 sourcemap，（譬如 babel 的 sourcemap） cheap-module-source-map 不包含列信息，同时 loader 的 sourcemap 也被简化为只包含对应行的。最终的 sourcemap 只有一份，它是 webpack 对 loader 生成的 sourcemap 进行简化，然后再次生成的。 webpack 不仅支持这 7 种，而且它们还是可以任意组合的，就如文档所说，你可以设置 souremap 选项为 cheap-module-inline-source-map。 这么多模式，到底该用哪个？ cheap-module-eval-source-map 绝大多数情况下都会是最好的选择，这也是下版本 webpack 的默认选项。 相关解释： 大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息，所以我们使用 cheap 模式可以大幅提高 souremap 生成的效率。 使用 eval 方式可大幅提高持续构建效率，参考 webapck devtool 文档 下方速度对比表格，这对经常需要边改边调的前端开发而言，非常重要！ 使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用）。 eval-source-map 使用 DataUrl 本身包含完整 sourcemap 信息，并不需要像 sourceURL 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率 解决此问题就是配置成这样 devtool: ‘#inline-eval-cheap-source-map’看到问题不要怕，这是我们做技术最希望遇到的，因为你可以非常快的提升，当你长时间没遇到问题，你觉得会有好处么？]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发栈所需要了解的内容]]></title>
    <url>%2F2018%2F01%2F12%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A0%88%E6%89%80%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Fakerjs（模拟数据） https://github.com/marak/Faker.js/storybook（UI的测试组件） https://github.com/storybooks/storybookrollup（JavaScript 模块打包器）https://github.com/rollup/rollupsocket.io https://github.com/socketio/socket.iomobx（简单、可扩展的状态管理） https://github.com/mobxjs/mobxVUX（Vue.js 移动端 UI 组件库） https://vux.li/]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JavaScript 异步系列（1）——基础]]></title>
    <url>%2F2017%2F06%2F18%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript-%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第一部分，什么是异步提醒：如果你是初学 js 的同学，尚未有太多项目经验和基础知识，请就此打住，不要看这篇教程 我思考问题、写文章一般都不按讨论出牌，别人写过的东西我不会再照着抄一遍。因此，后面所有的内容，都是我看了许多资料之后，个人重新思考提炼总结出来的，这肯定不能算是初级教程。 如果你是已有 js 开发经验，并了解异步的基础知识，到这里来想深入了解一下Promise Generator和async-awati，那就太好了，非常欢迎。 本节内容概述1、JS 为何会有异步 2、异步的实现原理是什么 3、常用的异步操作有哪些 1、JS 为何会有异步首先记住一句话 —— JS 是单线程的语言，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，上面的执行为完成，就傻傻的等着。例如 1234var i, t = Date.now()for (i = 0; i &lt; 100000000; i++) &#123;&#125;console.log(Date.now() - t) // 250 （chrome浏览器） 上面的程序花费 250ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。 执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的 js ，可能会有大量的网络请求，而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？———— 那肯定不行。 因此，JS 对于这种场景就设计了异步 ———— 即，发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说。这样就能保证一个网页的流程运行。 2、异步的实现原理先看一段比较常见的代码 123456var ajax = $.ajax(&#123; url: '/data/data1.json', success: function () &#123; console.log('success') &#125;&#125;) 上面代码中$.ajax()需要传入两个参数进去，url和success，其中url是请求的路由，success是一个函数。这个函数传递过去不会立即执行，而是等着请求成功之后才能执行。对于这种传递过去不执行，等出来结果之后再执行的函数，叫做callback，即回调函数 再看一段更加能说明回调函数的 nodejs 代码。和上面代码基本一样，唯一区别就是：上面代码时网络请求，而下面代码时 IO 操作。 1234var fs = require('fs')fs.readFile('data1.json', (err, data) =&gt; &#123; console.log(data.toString())&#125;) 从上面两个 demo 看来，实现异步的最核心原理，就是将callback作为参数传递给异步执行函数，当有结果返回之后再触发 callback执行，就是如此简单！ 3、常用的异步操作开发中比较常用的异步操作有： · 网络请求，如ajax http.get · IO 操作，如readFile readdir · 定时函数，如setTimeout setInterval 最后，请思考，事件绑定是不是也是异步操作？例如$btn.on(‘click’, function() {…})。这个问题很有意思，我会再后面的章节经过分析之后给出答案，各位先自己想一下。 第二部分，异步和 event-loop提到异步，就必须提 event-loop 。event-loop 中文翻译叫做“事件轮询”，它是能体现出单线程中异步操作是如何被执行的。 首先，强烈大家观看一个歪果仁的视频 《what the hack is event loop》. ，只有不到半个小时的时间，但是将的非常详细。 其次，再结合阮一峰老师的《什么是event loop》 一起看一下。将这两个看完就基本了解 event loop 了 最后，event-loop 是一块内容比较独立的技术性知识，它是什么样子就是什么样子，讲解起来可变通性非常小。因此，本节说一下我对 event-loop 的理解和体会 本节内容概述1、举例说明 2、核心概念 3、思考问题 1、举例说明给出一段简单的 js 代码，并用比较通俗、简单的说法介绍一下执行过程。详细过程还需各位去看视频，因为我没必要把半小时的视频都写到这里。 123console.log('line 1')setTimeout(console.log, 1000, 'line 2')console.log('line 3') 2、核心概念以上一共三行代码，该程序被执行的时候，会依次挨行执行 第一步，执行第一行，将结果line 1打印出来第二步，执行第二行，注意此时会将这个操作暂时存储到其他地方，因为setTimeout是一个异步执行操作。第三步，执行第三行，将结果line 3打印出出来第四步，等待最后一行程序（一共三行）都全部执行完了，然后立马实时查看刚才暂存的异步操作有没有。如果有可执行的，就立即拿到出来继续执行。第五步，执行完毕之后，再实时查看暂存位置中是否还有未执行的异步回调。 以上只拿了setTimeout举例子，但是对于网络请求、IO操作、事件绑定道理都是一样的。如果我讲的简单例子你还是看不懂，一定要去看文章最初提到的《what the hack is event loop》视频，重要重要！！！ 3、思考问题第一题，以下代码的输出顺序是什么 123setTimeout(console.log, 0, 'a')console.log('b')console.log('c') 答案是b c a，有疑问的需要再去看上面的介绍或者那个视频。 第二题，以下代码中，最后输出的结果是否是 500 1234567var i, t = Date.now()for (i = 0; i &lt; 100000000; i++) &#123;&#125;function fn() &#123; console.log(Date.now() - t) // 输出多少？？？&#125;setTimeout(fn, 500) 答案是大于 500ms ，因为 for 函数需要花费一些时间，等 for 执行完之后再开始计算 500ms 之后执行 fn 第三题，事件绑定是不是异步操作？ 这个问题大家根据 event-loop 的讲解和视频来思考，我们下一节再给出解答。 第三部分，事件绑定算不算异步？如果你认真看了上一节的 event-loop 的，你会发现原来事件绑定和异步操作的实现机制是一样的，那么事件绑定是不是就是异步操作呢？（声明一下，这里说的事件绑定是如下代码的形式） 123$btn.on('click', function (e) &#123; console.log('你点击了按钮')&#125;) PS：这个问题貌似没有加过有人讨论或者发起讨论，但是当我了解了 event-loop 之后，我就发现这两者有很大联系，很早就像讨论一下这个话题。不知道哪位同仁跟我有一样的想法？ 本节内容概述 · 共同之处· 不同之处· 我的观点]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（17）完结]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8817%EF%BC%89%E5%AE%8C%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前一共用15篇文章，把javascript的原型和闭包。 首先，javascript本来就“不容易学”。不是说它有多难，而是学习它的人，往往都是在学会了其他语言之后，又学javascript。有其他语言的学习经历和实践经历，再加上自学javascript，边学边用，肯定会产生许多误解，走许多弯路。我就没少经历，也算是一种教训。 其次，原型和闭包又是一对难兄难弟，一来是他俩比较难懂，二来是他俩都或多或少的给初级开发人员带来许多BUG。不懂原型和闭包，你也可以开发javascript程序，但是你写不出高质量、符合设计原则的javascript程序。 因此，还是强调基础，强调理论！理论和实践相结合不是一句空话。 由此想到了我平时练习投篮。一般喜欢篮球的人都是周末和别人去一起打篮球玩，我之前也是如此。但是我从今年春天开始，每周另外抽出一小时时间，自己一个人去练习投篮。练习正确的投篮姿势，强迫自己在练习的时候使用正确姿势，时间长了就形成了肌肉记忆。所以，工作之余，切不可忘记充电。 最后，看到好多文章都是长篇大论，恨不得用一篇文章解释完所有的内容。而我的文章都是小步快跑，看完一篇估计也就十分钟。这是我在看《明朝那些事儿》时发现的一个思路。这本书一节只有很少的内容，而且语言简单，演绎性很强，一节紧扣着一节，能黏住读者。 因此，我在写文章时，会先用一个大家都知道的概念引入正题，然后进一步解释。在一篇文章的最后，要抛出一个疑问引出下一节。 原型和闭包这个系列，正好填补了javascript教程一个空缺，即使《javascript高级程序设计》中，都没有将原型和闭包讲解的如此深入。希望大家多多支持吧。 就此，结束。 其实在我们日常生活中，我们回答问题也是一样道理，需要有逻辑性以及合理的解释，不要长篇大论的解释，而是精辟.]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（16）上下文环境和作用域的关系]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8816%EF%BC%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。 再说明之前，咱们先用简单的语言来概括一下这两个的区别。 00 上下文环境： 可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？ 另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？ 01 作用域： 首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。 02 两者： 一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。 上面的文字不理解没关系，且看下面的例子。 第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。 第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。 第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。 第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。 第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境。 讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。 目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（15）闭包]]></title>
    <url>%2F2017%2F06%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8815%EF%BC%89%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。 至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。 但是你只需要知道应用的两种情况即可——1、函数作为返回值，2、函数作为参数传递。 第一，函数作为返回值 如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。 第二，函数作为参数被传递 如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（不明白的朋友一定要去上一节看看，这个很重要！） 另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。 在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。 但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。 咱们可以拿本文的第一段代码（稍作修改）来分析一下。 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图： 第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。 执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。 使用闭包会增加内容开销，现在很明显了吧！ 第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。 闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！ 另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。 到现在闭包就简单介绍完了，下一节我们再总结一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（14）从【自由变量】到【作用域链】]]></title>
    <url>%2F2017%2F06%2F14%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8814%EF%BC%89%E4%BB%8E%E3%80%90%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F%E3%80%91%E5%88%B0%E3%80%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[先解释一下什么是“自由变量”。 在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图 1234567var x = 10function fn () &#123; var b = 20; console.log(x+b) //这里的x在这里就是一个自由变量&#125; 如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？ 有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如： 1234567891011121314var x = 10function fn () &#123; console.log(x)&#125;function show () &#123; var x = 20 (function () &#123; f() //10 而不是20 &#125;)()&#125;show() 所以，不要在用以上说法了。 相比而言，用这句话描述会更加贴切–要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记–其实这就是所谓的“静态作用域” 对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。 上面描述的只是跨一步作用域去寻找。 如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。 这个一步一步“跨”的路线，我们称之为——作用域链。 我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量） 第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续； 第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续； 第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域； 第四步，跳转到第一步。 以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。 这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。 接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（13）【作用域】和【上下文环境】]]></title>
    <url>%2F2017%2F06%2F13%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8813%EF%BC%89%E3%80%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91%E5%92%8C%E3%80%90%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E3%80%91%2F</url>
    <content type="text"><![CDATA[上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。 如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。 下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。 第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。 第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。 第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。 第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。 第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。 第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。 结束了。 最后我们可以把以上这几个图片连接起来看看。 连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。 以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（12）简介【作用域】]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8812%EF%BC%89%E7%AE%80%E4%BB%8B%E3%80%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：12345var i = 10if( i &gt; 1 )&#123; var name = '张三'&#125;console.log(name) //张三 再比如for语句： 1234for(var i = 0; i &lt; 10; i ++ )&#123; //...&#125;console.log(i) // 10 所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：12345var i ;for(var i = 0; i &lt; 10; i ++ )&#123; //...&#125;console.log(i) // 10 其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。 所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。 jQuery就是一个很好的示例： 下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘” 如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。 说到这里，咱们又可以拿出jquery源码来讲讲了。 jQuery源码的最外层是一个自动执行的匿名函数： 为什么要这样做呢？ 原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。 全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。 作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。 下一节将把作用域和执行上下文环境结合起来说一说。 可见，要理解闭包，不是一两句话能说清楚的。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（11）执行上下文栈]]></title>
    <url>%2F2017%2F06%2F11%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8811%EF%BC%89%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%2F</url>
    <content type="text"><![CDATA[执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。 其实这是一个压栈出栈的过程——执行上下文栈。如下图： 可根据以下代码来详细介绍上下文栈的压栈、出栈过程。 1234567891011121314var a = 10; //1、进入全局上下文环境var fn;var bar = function (x) &#123; var b = 5; console.log(fn) fn(x + b) //3、进入fn函数上下文环境&#125;fn = function (y) &#123; var c = 5 console.log(y+c) &#125;bar(10) //2、进入bar上下文环境 如上代码。 在执行代码之前，首先将创建全局上下文环境。 然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。 执行到第13行，调用bar函数。 跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。 并将这个执行上下文环境压栈，设置为活动状态。 执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。 待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。 讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。 要说闭包，咱们还得先从自由变量和作用域说起。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（10）this]]></title>
    <url>%2F2017%2F06%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8810%EF%BC%89this%2F</url>
    <content type="text"><![CDATA[接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。 其实，this的取值，分四种情况。我们来挨个看一下。 在此再强调一遍一个非常重要的知识点：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。 情况1：构造函数所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。 1234567891011function Foo() &#123; this.name = '张三' this.year = 1990 console.log(this) //Foo &#123;name: "张三", year: 1990&#125;&#125;var f1 = new Foo()console.log(f1.name) //张三console.log(f1.year) //1990 以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。 12345678function Foo() &#123; this.name = '张三' this.year = 1990 console.log(this) //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;&#125;Foo() 这种情况下this是window，我们后文中会说到。 情况2：函数作为对象的一个属性如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。 12345678var obj = &#123; x: 10, fn: function () &#123; console.log(this); //&#123;x: 10, fn: ƒ&#125; console.log(this.x);//10 &#125;&#125;obj.fn() 以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象 注意，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？12345678var obj = &#123; x: 10, fn: function () &#123; console.log(this); //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; console.log(this.x);//undefined &#125;&#125;obj.fn()如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。### 情况3：函数用call或者apply调用当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。123456789var obj = &#123; x: 10,&#125;var fn = function () &#123; console.log(this); //&#123;x: 10, fn: ƒ&#125; console.log(this.x);//10 &#125;fn.call(obj)### 情况4：全局 &amp; 调用普通函数在全局环境下，this永远是window，这个应该没有非议。1console.log(this === window)普通函数在调用时，其中的this也都是window。12345678var x = 10;var fn = function () &#123; console.log(this); ////Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; console.log(this.x);//10 &#125; fn()以上代码很好理解。不过下面的情况你需要注意一下： 1234567891011121314var obj = &#123; x: 10, fn : function () &#123; function f () &#123; console.log(this); //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; console.log(this.x); //undefined &#125; f() &#125;&#125;obj.fn() 函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。 情况5：构造函数在构造函数的prototype中，this代表着什么。 123456789101112function Fn () &#123; this.name = '张三' this.year = 1990&#125;Fn.prototype.getName = function () &#123; console.log(this.name); &#125;var f1 = new Fn()f1.getName() //张三 如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。 其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象。 完了。 看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。 最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。 以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。 执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。 这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。 好了，聊完了this。接着上一节继续说“执行上下文栈”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（9）简述【执行上下文】下]]></title>
    <url>%2F2017%2F06%2F09%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%889%EF%BC%89%E7%AE%80%E8%BF%B0%E3%80%90%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%91%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据： 变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值； 如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码： 以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。 另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下： 好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。 全局代码的上下文环境数据内容为： 如果代码段是函数体，那么在此基础上需要附加： 给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。 了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！ 讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。 不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。 说完this，接着说执行上下文栈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（8）简述【执行上下文】上]]></title>
    <url>%2F2017%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%888%EF%BC%89%E7%AE%80%E8%BF%B0%E3%80%90%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%91%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码： 第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。 在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟： 这是第一种情况。 下面还有。先来个简单的。 有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。 与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。 下面还有。。。第三种情况。 在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。 看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。 没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。 好了，“准备工作”介绍完毕。 我们总结一下，在“准备工作”中完成了哪些工作： 1、变量、函数表达式——变量声明，默认赋值为undefined；2、this——赋值；3、函数声明——赋值； 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。 这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。 细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。 其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。 这里解释一下为什么代码段分为这三种。 所谓“代码段”就是一段文本形式的代码。 首先，全局代码是一种，这个应该没有非议，本来就是手写文本到&lt; script &gt;标签里面的。 1234&lt;script type="text/javascript"&gt; //代码段&lt;/script&gt; 其次，eval代码接收的也是一段文本形式的代码。 1eval('alert(3)') 最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。 12345function fn (x) &#123; console.log(x+5)&#125;var fn = new Function('x', 'console.log(x+5)') 这样解释应该能理解了。 最后，eval不常用，也不推荐大家用。 下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（7）原型的灵活性]]></title>
    <url>%2F2017%2F06%2F07%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%887%EF%BC%89%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。 而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。 首先，对象属性可以随时改动。 对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。 在jQuery的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。 其次，如果继承的方法不合适，可以做出修改。 如上图，Object和Array的toString()方法不一样。肯定是Array.prototype.toString()方法做了修改。 同理，我也可以自定义一个函数，并自己去修改prototype.toString()方法。 123456789function Foo () &#123;&#125;;var f1 = new Foo();Foo.prototype.toString = function () &#123; return '张三'&#125;console.log(f1.toString()) 最后，如果感觉当前缺少你要用的方法，可以自己去创建。 例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。 如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（6）继承]]></title>
    <url>%2F2017%2F06%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%886%EF%BC%89%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[为何用“继承”为标题，而不用“原型链”？ 原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。 javascript中的继承是通过原型链来体现的。先看几句代码 以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.proto指向的是Foo.prototype 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 看图说话： 上图中，访问f1.b时，f1的基本属性中没有b，于是沿着proto找到了Foo.prototype.b。 那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。 等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？ 好问题。 它是从Object.prototype中来的，请看图： 对象的原型链是沿着proto这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。 由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。 当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。 说一个函数的例子吧。 我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下： 看到了吧，有call、length等这些属性。 那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.proto是否指向Object.prototype。 原型、原型链，大家都明白了吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（5) instanceof]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%885-instanceof%2F</url>
    <content type="text"><![CDATA[又介绍一个老朋友——instanceof。 对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。 这个时候就需要用到instanceof。例如： 1234567function Foo() &#123;&#125;;var f1 = new Foo();console.log(f1 instanceof Foo) //trueconsole.log(f1 instanceof Object) //true 上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？ 至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图： Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。 通过上以规则，你可以解释很多比较怪异的现象，例如： 这些看似很混乱的东西，答案却都是true，这是为何？ 正好，这里也接上了咱们上一节说的“乱”。 上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即： 看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。 看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。 问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？ 重点就这样被这位老朋友给引出来了——继承——原型链。 即，instanceof表示的就是一种继承关系，或者原型链的结构。请看下节分解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（4）隐式原型]]></title>
    <url>%2F2017%2F06%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%884%EF%BC%89%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看《javascript高级程序设计（第三版）》第6章：面向对象的程序设计。 上节已经提到，每个函数function都有一个prototype，即原型这里再加一句话每个对象都有一个proto，可成为隐式原型。 这个proto是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在Visual Studio 2012这样很高级很智能的编辑器中，都不会有proto的智能提示，但是你不用管它，直接写出来就是了。 上面截图看来，obj.proto和Object.prototype的属性一样！这么巧！ 答案就是一样。 obj这个对象本质上是被Object函数创建的，因此obj.proto=== Object.prototype。我们可以用一个图来表示。 即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 那么上图中的“Object prototype”也是一个对象，它的proto指向哪里？ 好问题！ 在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype。 但是Object.prototype确是一个特例——它的proto指向的是null，切记切记！ 还有——函数也是一种对象，函数也有proto吗？ 又一个好问题！——当然有。 函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 且看如下代码。 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。 首先根本不推荐用第二种方式。 这里只是向大家演示，函数是被Function创建的。 好了，根据上面说的一句话——对象的proto指向的是创建它的函数的prototype，就会出现：Object.proto === Function.prototype。用一个图来表示。 上图中，很明显的标出了：自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，唉，怎么还有一个……Function.proto指向Function.prototype？这不成了循环引用了？ 对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。 篇幅不少了，估计也都看烦了。快结束了。 最后一个问题：Function.prototype指向的对象，它的proto是不是也指向Object.prototype？ 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。 OK 本节结束，是不是很乱？ 乱很正常。那这一节就让它先乱着，下一节我们将请另一个老朋友来帮忙，把它理清楚。这位老朋友就是——instanceof。 具体内容，请看下节分解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（3）prototype原型]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%883%EF%BC%89prototype%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[既typeof之后的另一位老朋友！ prototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript的新朋友。 在咱们的第一节（深入理解javascript原型和闭包（1）一切都是对象）中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。 不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。 这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor(建造者)的属性，指向这个函数本身。 如上图，SuperType是是一个函数，右侧的方框就是它的原型。 原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。 咦，有些方法怎么似曾相似？ 对！别着急，之后会让你知道他们为何似曾相识。 接着往下说，你也可以在自己自定义的方法的prototype中新增自己的属性 12345function Fn() &#123; &#125;Fn.prototype.name = '张三';Fn.prototype.getYear = function () &#123; return 1990;&#125;; 看到没有，这样就变成了 没问题！ 但是，这样做有何用呢？ —— 解决这个问题，咱们还是先说说jQuery吧。 1234var $div = $('div');$div.attr('myName', '张三'); 以上代码中，$(‘div’)返回的是一个对象，对象——被函数创建的。假设创建这一对象的函数是 myjQuery。它其实是这样实现的。 12345myjQuery.prototype.attr = function () &#123; //……&#125;;$('div') = new myjQuery(); 不知道大家有没有看明白。 如果用咱们自己的代码来演示，就是这样 123456789function Fn() &#123; &#125;Fn.prototype.name = '张三';Fn.prototype.getYear = function () &#123; return 1990;&#125;;var fn = new Fn();console.log(fn.name);console.log(fn.getYear()); 即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性——“proto”，这个属性引用了创建这个对象的函数的prototype。即：fn.proto === Fn.prototype 这里的”proto“成为“隐式原型”，下回继续分解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（2）函数和对象的关系]]></title>
    <url>%2F2017%2F06%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%882%EF%BC%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[上文（理解javascript原型和作用域系列（1) 一切都是对象）已经提到，函数就是对象的一种，因为通过instanceof函数可以判断。 12var fn = function () &#123; &#125;;console.log(fn instanceof Object); // true 对！函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。 还是先看一个小例子吧。 12345function Fn() &#123; this.name = '章三'; this.year = 1990;&#125;var fn1 = new Fn(); 上面的这个例子很简单，它能说明：对象可以通过函数来创建。对！也只能说明这一点。 1但是我要说——对象都是通过函数创建的——有些人可能反驳：不对！因为： 12var obj = &#123; a: 10, b: 20 &#125;;var arr = [5, 'x', true]; 但是不好意思，这个——真的——是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。 做“语法糖”做的最好的可谓是微软大哥，它把他们家C#那小子弄的不男不女从的，本想图个人见人爱，谁承想还得到处跟人解释——其实它是个男孩！ 话归正传——其实以上代码的本质是： 123456789101112//var obj = &#123; a: 10, b: 20 &#125;;//var arr = [5, 'x', true];var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = 'x';arr[2] = true; 而其中的 Object 和 Array 都是函数： 12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 所以，可以很负责任的说——对象都是通过函数来创建的。 现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？ 别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype原型。 本系列文章不打算动辄几千字的长篇大论，咱们小步快跑，不至于看的太乏味。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript原型和闭包（1）一切都是对象]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%881%EF%BC%89%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[javascript作为前端最基础的语言，是我们必须需要掌握的核心，不同的时间段的理解会有变化。那么接下来记录一下自己从事前端以来，现阶段自己所认识的js “一切都是对象”这句话的重点在于如何去理解“对象”这个概念。 ——当然，也不是所有的都是对象，值类型就不是对象。 首先咱们还是先看看javascript中一个常用的运算符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？ typeof函数输出的一共有几种类型，在此列出： 12345678910111213141516function show(x) &#123; console.log(typeof x); // undefined console.log(typeof 10); // number console.log(typeof 'abc'); // string console.log(typeof true); // boolean console.log(typeof function () &#123;&#125;); //function console.log(typeof [1, 'a', true]); //object console.log(typeof &#123; a: 10, b: 20 &#125;); //object console.log(typeof null); //object console.log(typeof new Number(10)); //object&#125;show(); 关于null的typeof和instanceof 链接👉https://blog.csdn.net/microcosmv/article/details/54565619?utm_source=itdadao&amp;utm_medium=referral JavaScript中的数组与伪数组的区别 链接👉https://www.cnblogs.com/chenpingzhao/p/4764791.html 12345678910111213141516171819在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。基本数据类型：String,boolean,Number,Undefined, Null引用数据类型：Object(Array,Date,RegExp,Function)``` 以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。### 判断一个变量是不是对象非常简单。1、值类型的类型判断用typeof2、引用类型的类型判断用instanceof```javascriptvar fn = function () &#123; &#125;;console.log(fn instanceof Object); // true 函数是一个特殊的对象 对象——若干属性的集合。java或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。 而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。 先说个最常见的例子： 12345678910var obj = &#123; a: 10, b: function () &#123; &#125;, c: &#123; name: '章三', age: 20 &#125;&#125; 以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。 这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合 以函数为例子： 1234567891011var fn = function () &#123; alert(100);&#125;;fn.a = 10;fn.b = function () &#123; alert(123);&#125;;fn.c = &#123; name: "章三", year: 20&#125;; 上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。 你问：这个有用吗？ 回答：可以看看jQuery源码！ 在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。 console.log(typeof $); // function console.log($.trim(“ ABC “)); 验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！ 很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。 javascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。 1其次要解释的就是本文的内容——一切（引用类型）都是对象，对象是属性的集合。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！ 最后，有个疑问。在typeof的输出类型中，function和object都是对象，为何却要输出两种答案呢？都叫做object不行吗？——当然不行。 具体原因，且听下回分解]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript展望]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%B1%95%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[JS三座大山这个概念 原型作用域异步]]></content>
  </entry>
</search>
