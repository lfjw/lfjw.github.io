{"total":19,"pageSize":10,"pageCount":2,"data":[{"title":"mac安装nginx","slug":"mac安装nginx","date":"2018-05-24T03:31:38.000Z","updated":"2018-05-24T05:32:29.000Z","comments":true,"path":"api/articles/mac安装nginx.json","excerpt":"","keywords":null,"cover":null,"content":"<p>首先在你的终端上输入brew</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example usage:</span><br><span class=\"line\">  brew search [TEXT|/REGEX/]</span><br><span class=\"line\">  brew info [FORMULA...]</span><br><span class=\"line\">  brew install FORMULA...</span><br><span class=\"line\">  brew update</span><br><span class=\"line\">  brew upgrade [FORMULA...]</span><br><span class=\"line\">  brew uninstall FORMULA...</span><br><span class=\"line\">  brew list [FORMULA...]</span><br><span class=\"line\"></span><br><span class=\"line\">Troubleshooting:</span><br><span class=\"line\">  brew config</span><br><span class=\"line\">  brew doctor</span><br><span class=\"line\">  brew install --verbose --debug FORMULA</span><br><span class=\"line\"></span><br><span class=\"line\">Contributing:</span><br><span class=\"line\">  brew create [URL [--no-fetch]]</span><br><span class=\"line\">  brew edit [FORMULA...]</span><br><span class=\"line\"></span><br><span class=\"line\">Further help:</span><br><span class=\"line\">  brew commands</span><br><span class=\"line\">  brew help [COMMAND]</span><br><span class=\"line\">  man brew</span><br><span class=\"line\">  https://docs.brew.sh</span><br></pre></td></tr></table></figure>\n<p>如果是这玩意恭喜你，可以直接安装了</p>\n<p>如果提示是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-bash: brew: command not found</span><br></pre></td></tr></table></figure>\n<p>那么需要进行安装</p>\n<p>可以移步查看brew的官网👉<a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"noopener\">https://brew.sh/index_zh-cn</a></p>\n<p>很多人可能不了解 Homebrew, 其实它相当于开发软件界的 Appstore.</p>\n<p>比如,如果我要安装 python 的最新版本,那么传统的做法是 </p>\n<ul>\n<li>1 到官方网站下载 python 的最新版本 </li>\n<li>2 极其麻烦和小心翼翼的删除自带的 python 版本 </li>\n<li>3 安装新的版本 </li>\n<li>4 设置环境变量</li>\n</ul>\n<p>而借助 Homebrew, 需要做的仅仅是:<br>brew uninstall python<br>brew install python</p>\n<p>整个过程只是等待而已,不需要百度 python 的官方网址,不需要找卸载安装配置环境变量教程…</p>\n<h3 id=\"如何安装brew\"><a href=\"#如何安装brew\" class=\"headerlink\" title=\"如何安装brew\"></a>如何安装brew</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li><p>因网络的原因,可能会不成功,请多尝试几次,一直到成功安装.</p>\n</li>\n<li><p>中间会出现一个 Press RETURN to continue or any other key to abort,【请及时回车,并输入密码】</p>\n</li>\n</ul>\n<p>当结尾出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Next steps:</span><br><span class=\"line\">- Run `brew help` to get started</span><br><span class=\"line\">- Further documentation: </span><br><span class=\"line\">    https://docs.brew.sh</span><br></pre></td></tr></table></figure>\n<p>可以在输入brew进行查看，如果为开头说提示的内容，恭喜你安装成功💥💥</p>\n<h3 id=\"那么接下里看nginx\"><a href=\"#那么接下里看nginx\" class=\"headerlink\" title=\"那么接下里看nginx\"></a>那么接下里看nginx</h3><p>不要输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo brew install nginx</span><br></pre></td></tr></table></figure>\n<p>会提示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Running Homebrew as root is extremely dangerous and no longer supported.</span><br><span class=\"line\">As Homebrew does not drop privileges on installation you would be giving all</span><br><span class=\"line\">build scripts full access to your system.</span><br><span class=\"line\">bogon:~ jiwei$ brew install nginx</span><br><span class=\"line\">Updating Homebrew...</span><br></pre></td></tr></table></figure>\n<p>直接输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install nginx</span><br></pre></td></tr></table></figure>\n<p>安装完成</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n<p>会提示版本号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx version: nginx/1.13.12</span><br></pre></td></tr></table></figure>\n<p>启动nginx 输入 <a href=\"http://localhost:8080，\" target=\"_blank\" rel=\"noopener\">http://localhost:8080，</a></p>\n<p>这里告诉大家几个常见的命令</p>\n<h4 id=\"启动-nginx\"><a href=\"#启动-nginx\" class=\"headerlink\" title=\"启动 nginx\"></a>启动 nginx</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭nginx\"><a href=\"#关闭nginx\" class=\"headerlink\" title=\"关闭nginx\"></a>关闭nginx</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s stop</span><br></pre></td></tr></table></figure>\n<h4 id=\"重新加载nginx【例如你修改了nginx的配置，需要这个命令来让你的内容生效】\"><a href=\"#重新加载nginx【例如你修改了nginx的配置，需要这个命令来让你的内容生效】\" class=\"headerlink\" title=\"重新加载nginx【例如你修改了nginx的配置，需要这个命令来让你的内容生效】\"></a>重新加载nginx【例如你修改了nginx的配置，需要这个命令来让你的内容生效】</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>到此你的mac上就有了nginx</p>\n<p>扩展个内容在这需要了解的几个路径</p>\n<p>1、</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/etc/nginx</span><br></pre></td></tr></table></figure>\n<p>这个文件下的nginx.conf，可以进行一些配置。</p>\n<p>2、</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/Cellar/nginx/1.13.12/html</span><br></pre></td></tr></table></figure>\n<p>这是放置静态资源的内容</p>\n","text":"首先在你的终端上输入brew1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"在vue中使用sass的配置的方法","slug":"在vue中使用sass的配置的方法","date":"2018-05-21T03:42:48.000Z","updated":"2018-05-21T03:46:49.000Z","comments":true,"path":"api/articles/在vue中使用sass的配置的方法.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"1、创建一个基于-webpack-模板的新项目\"><a href=\"#1、创建一个基于-webpack-模板的新项目\" class=\"headerlink\" title=\"1、创建一个基于 webpack 模板的新项目\"></a>1、创建一个基于 webpack 模板的新项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack myvue</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、在当前目录下，安装依赖\"><a href=\"#2、在当前目录下，安装依赖\" class=\"headerlink\" title=\"2、在当前目录下，安装依赖\"></a>2、在当前目录下，安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myvue</span><br><span class=\"line\"></span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、安装sass的依赖包\"><a href=\"#3、安装sass的依赖包\" class=\"headerlink\" title=\"3、安装sass的依赖包\"></a>3、安装sass的依赖包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev sass-loader</span><br><span class=\"line\">//sass-loader依赖于node-sass</span><br><span class=\"line\">npm install --save-dev node-sass</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、在build文件夹下的webpack-base-conf-js的rules里面添加配置\"><a href=\"#4、在build文件夹下的webpack-base-conf-js的rules里面添加配置\" class=\"headerlink\" title=\"4、在build文件夹下的webpack.base.conf.js的rules里面添加配置\"></a>4、在build文件夹下的webpack.base.conf.js的rules里面添加配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: /\\.scss$/,</span><br><span class=\"line\">  loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、在APP-vue中修改style标签\"><a href=\"#5、在APP-vue中修改style标签\" class=\"headerlink\" title=\"5、在APP.vue中修改style标签\"></a>5、在APP.vue中修改style标签</h3><style lang=\"scss\">\n\n\n\n\n\n\n\n\n</style>","text":"1、创建一个基于 webpack 模板的新项目1<br>vue init webpack myvue<br>2、在当前目录下，安装依赖1<br>2<br>3<br>cd myvue<br><br>npm install<br>3、安装sass的依赖包1<br>2<br>3<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"git实际开发遇到的问题以及解决方式","slug":"git实际开发遇到的问题以及解决方式","date":"2018-05-18T06:03:32.000Z","updated":"2018-05-18T06:17:09.000Z","comments":true,"path":"api/articles/git实际开发遇到的问题以及解决方式.json","excerpt":"","keywords":null,"cover":null,"content":"<p>在实际工作当中，我们会遇到git的一些问题，总结了一些解决方法</p>\n<h2 id=\"1、git-如何把远程分支搞下来\"><a href=\"#1、git-如何把远程分支搞下来\" class=\"headerlink\" title=\"1、git 如何把远程分支搞下来\"></a>1、git 如何把远程分支搞下来</h2><p>当我想从远程仓库里拉取一条本地不存在的分支时</p>\n<p>git checkout -b 本地分支名 origin/远程分支名</p>\n<p>如果出现提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.</span><br><span class=\"line\">Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</span><br></pre></td></tr></table></figure>\n<p>表示拉取不成功。我们需要先执行</p>\n<p>git fetch</p>\n<p>然后再执行</p>\n<p>git checkout -b 本地分支名 origin/远程分支名</p>\n<p>即可。</p>\n<h2 id=\"2、本地检出一个新的分支并推送到远程仓库\"><a href=\"#2、本地检出一个新的分支并推送到远程仓库\" class=\"headerlink\" title=\"2、本地检出一个新的分支并推送到远程仓库\"></a>2、本地检出一个新的分支并推送到远程仓库</h2><ul>\n<li>创建本地分支</li>\n</ul>\n<p>git checkout -b 新分支名</p>\n<p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上检出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p>\n<p>比如我要创建一个名为dev1的新分支：</p>\n<p>此时，再执行git branch查看当前本地所有分支，就会看到两个分支：master与dev1.</p>\n<ul>\n<li>推送本地分支到远程仓库</li>\n</ul>\n<p>git push –set-upstream origin 分支名</p>\n<!-- https://www.cnblogs.com/hamsterPP/p/6810831.html\n -->\n","text":"在实际工作当中，我们会遇到git的一些问题，总结了一些解决方法1、git 如何把远程分支搞下来当我想从远程仓库里拉取一条本地不存在的分支时git checkout -b 本地分支名 origin/远程分支名如果出现提示：1<br>2<br>fatal: Cannot update","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"深入了解跨域问题，以及解决的方式","slug":"深入了解跨域问题，以及解决的方式","date":"2018-05-09T01:29:28.000Z","updated":"2018-05-09T09:39:51.000Z","comments":true,"path":"api/articles/深入了解跨域问题，以及解决的方式.json","excerpt":"","keywords":null,"cover":null,"content":"<p>对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事</p>\n<h4 id=\"跨域的含义\"><a href=\"#跨域的含义\" class=\"headerlink\" title=\"跨域的含义\"></a>跨域的含义</h4><p>跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 页面去请求 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</p>\n<h4 id=\"为什么浏览器要限制跨域访问呢？\"><a href=\"#为什么浏览器要限制跨域访问呢？\" class=\"headerlink\" title=\"为什么浏览器要限制跨域访问呢？\"></a>为什么浏览器要限制跨域访问呢？</h4><p>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：</p>\n<ul>\n<li>用户访问<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器</li>\n<li>用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 <a href=\"http://www.xiee.com\" target=\"_blank\" rel=\"noopener\">www.xiee.com</a></li>\n<li>这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> 的操作。 </li>\n<li>如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。</li>\n</ul>\n<h4 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h4><p>看到这，我要吐个槽，在我以前面试的经历当中，有一位年轻的面试官，问了我一个问题，怎么解决跨域，我说通过nginx反向代理，他跟我说，没用过jsonp么，那个表情，好比再说，你连jsonp都不知道么。所以说，技术面试，一般不仅仅是对面试者的考验，更是面的人的一种考验。</p>\n<p>继续咱们的！！！</p>\n<p>不知道同学们有木有用过vue-cli脚手架，在config/index.js中有一段本地开发如何解决跨域的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxyTable: &#123;</span><br><span class=\"line\">    &apos;/apis&apos;: &#123;</span><br><span class=\"line\">        target: &apos;http://xxx/&apos;,</span><br><span class=\"line\">        changeOrigin: true,</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/apis&apos;: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>首先让我们来看看这个东西实现的原理，</p>\n<p>他依赖的是http-proxy-middleware，了解它的自行百度</p>\n<p>这段代码的意思就是，本地反向代理。此原理同样应用到服务器端，在nginx上，配置一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~/apis/&#123;</span><br><span class=\"line\">\trewrite ^/apis/(.*)$ /$1 break;</span><br><span class=\"line\">\tproxy_pass http://xxx/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下做一个解释</p>\n<p>1.’^~ /apis/ ‘</p>\n<ul>\n<li>这是是一个匹配规则，用于拦截请求，匹配任何以 /apis/开头的地址，匹配符合以后，停止往下搜索正则。</li>\n</ul>\n<p>2.rewrite ^/apis/(.*)$ /$1 break;</p>\n<ul>\n<li>代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如<a href=\"http://www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。\" target=\"_blank\" rel=\"noopener\">www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。</a></li>\n</ul>\n<p>　　<em> rewrite后面的参数是一个简单的正则 ^/apis/(.</em>)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。</p>\n<p>　　* break代表匹配一个之后停止匹配。</p>\n<p>3.proxy_pass</p>\n<ul>\n<li><p>既是把请求代理到其他主机，其中 <a href=\"http://www.b.com/\" target=\"_blank\" rel=\"noopener\">http://www.b.com/</a> 写法和 <a href=\"http://www.b.com写法的区别如下\" target=\"_blank\" rel=\"noopener\">http://www.b.com写法的区别如下</a>:</p>\n</li>\n<li><p>不带/</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/&#123;</span><br><span class=\"line\">　　proxy_pass http://b.com:8300; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>带/</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/ &#123; </span><br><span class=\"line\">    proxy_pass http://b.com:8300/; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种配置，区别只在于proxy_pass转发的路径后是否带 “/”。</p>\n<ul>\n<li><p>针对情况1，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/</a> 作为根路径，请求test/路径下的资源。</p>\n</li>\n<li><p>针对情况2，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会变为\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会变为</a> <a href=\"http://proxy_pass/test.jsp，直接访问server的根资源。\" target=\"_blank\" rel=\"noopener\">http://proxy_pass/test.jsp，直接访问server的根资源。</a></p>\n</li>\n</ul>\n<p>修改配置后重启nginx代理就成功了。</p>\n<p>至此，我们的跨域问题配置大功告成。</p>\n<p>有什么疑问，可以上github，有我的练习方式，欢迎大家指正。</p>\n","text":"对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事跨域的含义跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com 页面去请求 ","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"使用nuxt","slug":"使用nuxt","date":"2018-05-07T09:59:11.000Z","updated":"2018-05-09T09:38:49.000Z","comments":true,"path":"api/articles/使用nuxt.json","excerpt":"","keywords":null,"cover":null,"content":"<p>关于nuxt，我在这里就不过多介绍了</p>\n<p><a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/</a></p>\n<p>大家可以自行查看</p>\n","text":"关于nuxt，我在这里就不过多介绍了https://zh.nuxtjs.org/大家可以自行查看","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"手把手教你撸electron","slug":"手把手教你撸electron","date":"2018-05-06T11:18:00.000Z","updated":"2018-05-09T09:39:26.000Z","comments":true,"path":"api/articles/手把手教你撸electron.json","excerpt":"","keywords":null,"cover":null,"content":"<p>electron 就不多介绍了，大家可以自行百度查看。</p>\n<p>那么接下来，结合我实际的经验教大家如何快速的搭建一个自己的electron案例</p>\n<p>我们使用的是<a href=\"https://github.com/SimulatedGREG/electron-vue\" target=\"_blank\" rel=\"noopener\">https://github.com/SimulatedGREG/electron-vue</a></p>\n<p>大家可以自行查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">npm install -g vue-cli</span><br><span class=\"line\"></span><br><span class=\"line\">vue init simulatedgreg/electron-vue my-project</span><br><span class=\"line\"></span><br><span class=\"line\">cd my-project</span><br><span class=\"line\"></span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<p>在这里安装的时候会咨询你选择</p>\n<p>electron-builder和electron-packager</p>\n<p>个人建议 electron-builder</p>\n","text":"electron 就不多介绍了，大家可以自行百度查看。那么接下来，结合我实际的经验教大家如何快速的搭建一个自己的electron案例我们使用的是https://github.com/SimulatedGREG/electron-vue大家可以自行查看1<br>2<br>3<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？","slug":"使用Vuejs-Vue-router-开发单页面，如何使得切换页面时能销毁原组件？","date":"2018-05-05T13:55:49.000Z","updated":"2018-05-09T09:38:53.000Z","comments":true,"path":"api/articles/使用Vuejs-Vue-router-开发单页面，如何使得切换页面时能销毁原组件？.json","excerpt":"","keywords":null,"cover":null,"content":"<p>问题：(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？<br>描述:</p>\n<p>我有一个单页面应用，有页面A和页面B，二者是同级组件，关系是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.map(&#123;</span><br><span class=\"line\">&apos;/a&apos;: &#123;</span><br><span class=\"line\">    component: A</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;/b&apos;: &#123;</span><br><span class=\"line\">    component: B</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>例如，第一次打开时，显示页面 A，页面 A 有一个setInterval事件，每隔一秒钟会向后台发送一个Ajax请求。这时我点击页面 A 上的跳转按钮，跳到页面 B，通过观察网络连接，发现页面 A 上的Ajax请求仍然在继续。</p>\n<p>请问应当进行什么样的设置，才能使得页面切换时，原来的组件就被销毁？</p>\n<p>这是个非常严重的问题，同级组件绑定的事件，还会在另一个组件里继续监听。所以我猜想会有简单的配置方法，但我看遍了 Vue 的文档和 Vue-router 的文档，也未发现相关配置。</p>\n<p>参考文档：</p>\n<p><a href=\"http://vuejs.github.io/vue-router/zh-cn/options.html\" target=\"_blank\" rel=\"noopener\">http://vuejs.github.io/vue-router/zh-cn/options.html</a></p>\n<p><a href=\"http://vuejs.org/guide/\" target=\"_blank\" rel=\"noopener\">http://vuejs.org/guide/</a></p>\n<p>解决方案1:</p>\n<p>1、setInterval事件和组件的生命周期没有直接关系。<br>2、setInterval会返回一个ID 值。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</p>\n<p>解决方案2:</p>\n<p>router切换时，原来的组件确实已经销毁了，你可以看到ready生命周期函数是每次都触发了的。你这里的问题不在于组件是否销毁，因为setInterval事件本身和组件没有关系。</p>\n<p>setInterval相当于该组件申请的一种资源，在使用该组件时获取，在离开该组件时释放。这个过程只能是你手动进行的。所以你应该在离开该组件时，比如route的deactivate或者beforeDestory生命周期函数里手动clearInterval。</p>\n<p>其实很多框架里都是这样，比如桌面程序中某个窗口初始化时需要打开数据库连接（我们也可以视为一种资源），当窗口关闭时，程序本身并不知道“打开数据库连接”的反向操作是什么。所以我们需要在窗口销毁的回调方法里手动去释放这个资源，去写断开连接的代码。</p>\n<p>解决方案3:</p>\n<p><a href=\"http://stackoverflow.com/questions/35104770/how-to-destroy-a-component-when-building-spa-with-vue-js-and-vue-router\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/35104770/how-to-destroy-a-component-when-building-spa-with-vue-js-and-vue-router</a></p>\n<p><a href=\"http://vuejs.github.io/vue-router/zh-cn/pipeline/deactivate.html\" target=\"_blank\" rel=\"noopener\">http://vuejs.github.io/vue-router/zh-cn/pipeline/deactivate.html</a></p>\n<p>以上介绍了“(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？”的问题解答，希望对有需要的网友有所帮助。<br>本文网址链接：<a href=\"http://www.codes51.com/itwd/1037580.html\" target=\"_blank\" rel=\"noopener\">http://www.codes51.com/itwd/1037580.html</a></p>\n<p>最后我根据解决方案1解决了，贴下我的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">  this.n = setInterval(() =&gt; &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  &#125;, 20000)</span><br><span class=\"line\">  this.n1 = setInterval(() =&gt; &#123;</span><br><span class=\"line\">     //...</span><br><span class=\"line\">  &#125;, 60000)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">beforeDestroy () &#123;</span><br><span class=\"line\">  clearInterval(this.n)</span><br><span class=\"line\">  clearInterval(this.n1)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","text":"问题：(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？<br>描述:我有一个单页面应用，有页面A和页面B，二者是同级组件，关系是这样的：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>r","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"elementui中el-upload自定义上传方法中遇到的问题","slug":"elementui中el-upload自定义上传方法中遇到的问题","date":"2018-05-04T12:44:50.000Z","updated":"2018-05-09T09:40:02.000Z","comments":true,"path":"api/articles/elementui中el-upload自定义上传方法中遇到的问题.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\"><a href=\"#由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\" class=\"headerlink\" title=\"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\"></a>由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">el-upload</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"upload-demo\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">ref</span>=<span class=\"string\">\"upload\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">action</span>=<span class=\"string\">\"http://127.0.0.1:5000/json/import\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:http-request</span>=<span class=\"string\">\"myUpload\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-preview</span>=<span class=\"string\">\"handlePreview\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-remove</span>=<span class=\"string\">\"handleRemove\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-error</span>=<span class=\"string\">\"handleError\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-success</span>=<span class=\"string\">\"handleSuccess\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:file-list</span>=<span class=\"string\">\"fileList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:auto-upload</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-button</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"trigger\"</span> <span class=\"attr\">size</span>=<span class=\"string\">\"small\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"primary\"</span>&gt;</span>选取文件<span class=\"tag\">&lt;/<span class=\"name\">el-button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-button</span> <span class=\"attr\">style</span>=<span class=\"string\">\"margin-left: 10px;\"</span> <span class=\"attr\">size</span>=<span class=\"string\">\"small\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"success\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"submitUpload\"</span>&gt;</span>上传到服务器<span class=\"tag\">&lt;/<span class=\"name\">el-button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"tip\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"el-upload__tip\"</span>&gt;</span>只能上传json文件，且不超过500kb<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myUpload(content) &#123;</span><br><span class=\"line\">    console.log(‘myUpload...‘);</span><br><span class=\"line\">    this.$axios(&#123;</span><br><span class=\"line\">        method: ‘post‘,</span><br><span class=\"line\">        url: content.action,</span><br><span class=\"line\">        timeout: 20000,</span><br><span class=\"line\">        data: content.file</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">         content.onSuccess(‘配时文件上传成功‘)</span><br><span class=\"line\">    &#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">        if (error.response) &#123;</span><br><span class=\"line\">             // The request was made and the server responded with a status code</span><br><span class=\"line\">             // that falls out of the range of 2xx</span><br><span class=\"line\">             content.onError(‘配时文件上传失败(‘ + error.response.status + ‘)，‘ + error.response.data);</span><br><span class=\"line\">        &#125; else if (error.request) &#123;</span><br><span class=\"line\">             // The request was made but no response was received</span><br><span class=\"line\">             // `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span><br><span class=\"line\">             // http.ClientRequest in node.js</span><br><span class=\"line\">            content.onError(‘配时文件上传失败，服务器端无响应‘);</span><br><span class=\"line\">       \t&#125; else &#123;</span><br><span class=\"line\">             // Something happened in setting up the request that triggered an Error</span><br><span class=\"line\">             content.onError(‘配时文件上传失败，请求封装失败‘);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式很常见，唯一要注意的点是在上传方法调用后判断结果成功或者失败的时候，需要回调el-upload控件的onSuccess和onError方法，为的是能够复用el-upload原生的一些动作，比如如果成功了，页面上的文件列表会有一个绿勾标记上传成功的文件，如果失败则会把失败的文件从文件列表中删除，如果不回调是没有这些功能的。</p>\n","text":"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"cordova安装及使用之android篇","slug":"cordova安装及使用之android篇","date":"2018-04-28T09:52:56.000Z","updated":"2018-05-09T09:39:57.000Z","comments":true,"path":"api/articles/cordova安装及使用之android篇.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"机型：mac\"><a href=\"#机型：mac\" class=\"headerlink\" title=\"机型：mac\"></a>机型：mac</h3><h3 id=\"本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\"><a href=\"#本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\" class=\"headerlink\" title=\"本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\"></a>本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本</h3><h3 id=\"纯属个人瞎搞，如果有不对的地方欢迎指正\"><a href=\"#纯属个人瞎搞，如果有不对的地方欢迎指正\" class=\"headerlink\" title=\"纯属个人瞎搞，如果有不对的地方欢迎指正\"></a>纯属个人瞎搞，如果有不对的地方欢迎指正</h3><p>先进入正题，使用此cordova首先是配备java环境，然后安装android-sdk</p>\n<p>一、安装jdk以及环境变量</p>\n<p>MAC系统安装JDK1.8及环境变量配置 👉 <a href=\"https://blog.csdn.net/deliciousion/article/details/78046007\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/deliciousion/article/details/78046007</a></p>\n<ul>\n<li><p>下载：jdk下载  👉 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n</li>\n<li><p>Mac设置安卓sdk环境变量   👉 <a href=\"https://blog.csdn.net/free_co/article/details/77115920\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/free_co/article/details/77115920</a></p>\n</li>\n</ul>\n<p>以下是我的配置</p>\n<p>设置JAVA_HOME环境变量，指定为JDK安装路径<br>设置ANDROID_HOME环境变量，指定为Android SDK安装路径<br>同时也建议你添加Android SDK的tools和platform-tools目录到你的PATH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</span><br><span class=\"line\">export ANDROID_HOME=/Users/你的用户名/library/Android/sdk</span><br><span class=\"line\">export PATH=$&#123;PATH&#125;:/Users/你的用户名/library/Android/sdk/platform-tools:/Users/你的用户名/library/Android/sdk/tool</span><br></pre></td></tr></table></figure>\n","text":"机型：mac本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本纯属个人瞎搞，如果有不对的地方欢迎指正先进入正题，使用此cordova首先是配备java环境，然后安装android-sdk一、安装jdk以及环境变量MAC系统安装JDK","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"如何查看页面是否开启了gzip压缩","slug":"如何查看页面是否开启了gzip压缩","date":"2018-04-27T12:35:44.000Z","updated":"2018-05-09T09:39:15.000Z","comments":true,"path":"api/articles/如何查看页面是否开启了gzip压缩.json","excerpt":"","keywords":null,"cover":"/2018/04/27/如何查看页面是否开启了gzip压缩/gzip.jpeg","content":"<h3 id=\"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\"><a href=\"#前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\" class=\"headerlink\" title=\"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\"></a>前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。</h3><h3 id=\"既然如此，让我们从以下几个方面说起\"><a href=\"#既然如此，让我们从以下几个方面说起\" class=\"headerlink\" title=\"既然如此，让我们从以下几个方面说起\"></a>既然如此，让我们从以下几个方面说起</h3><h4 id=\"HTTP-协议中的-Content-Encoding\"><a href=\"#HTTP-协议中的-Content-Encoding\" class=\"headerlink\" title=\"HTTP 协议中的 Content-Encoding\"></a>HTTP 协议中的 Content-Encoding</h4><pre><code>Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。\n工作原理：\n1、浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；\n2、服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；\n3、浏览器拿到响应正文后，依据 Content-Encoding 进行解压。\n4、当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。\n</code></pre><p>【内容编码】目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过 gzip 压缩过的文本响应，只有原始大小的 1/4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于 JPG / PNG 这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费 CPU。</p>\n<ul>\n<li><p>DEFLATE、ZLIB、GZIP 这种大写字符，表示数据压缩格式；</p>\n</li>\n<li><p>deflate、gzip 这种小写字符，表示 HTTP 中 Content-Encoding 的取值；</p>\n</li>\n<li><p>Gzip 特指 GUN zip 文件压缩程序，Zlib 特指 Zlib 库；</p>\n</li>\n</ul>\n<h4 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h4><p>这个详细内容请查看这个 👉 （Nginx配置详解）<a href=\"https://www.cnblogs.com/brant/p/7209048.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/brant/p/7209048.html</a></p>\n<h4 id=\"详解gzip\"><a href=\"#详解gzip\" class=\"headerlink\" title=\"详解gzip\"></a>详解gzip</h4><p>gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；</p>\n<p>Gzip压缩传输能更加有效节约带宽流量。他先把文本压缩为.gz然后传输给浏览器，最后由浏览器负责解压缩呈现给用户。</p>\n<p>老版本的浏览器可能不能显示，但是现在大多数浏览器都能显示。</p>\n<h4 id=\"如何查看是否开启gizp\"><a href=\"#如何查看是否开启gizp\" class=\"headerlink\" title=\"如何查看是否开启gizp\"></a>如何查看是否开启gizp</h4><h5 id=\"先来看看开启的请求\"><a href=\"#先来看看开启的请求\" class=\"headerlink\" title=\"先来看看开启的请求\"></a>先来看看开启的请求</h5><p><img src=\"/2018/04/27/如何查看页面是否开启了gzip压缩/gzip.jpeg\" style=\"height: 500px;width: auto;\"></p>\n<h5 id=\"再来看看没开启的请求\"><a href=\"#再来看看没开启的请求\" class=\"headerlink\" title=\"再来看看没开启的请求\"></a>再来看看没开启的请求</h5><p><img src=\"/2018/04/27/如何查看页面是否开启了gzip压缩/nogzip.jpeg\" style=\"height: 500px;width: auto;\"></p>\n<p>看到这个就可以给你的小伙伴说了，看吧，人家的开启了，你没开启，自己研究研究吧！！！</p>\n","text":"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研","link":"","raw":null,"photos":[],"categories":[],"tags":[]}]}