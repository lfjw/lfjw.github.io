{"title":"深入了解跨域问题，以及解决的方式","slug":"深入了解跨域问题，以及解决的方式","date":"2018-05-09T01:29:28.000Z","updated":"2018-05-09T09:00:11.000Z","comments":true,"path":"api/articles/深入了解跨域问题，以及解决的方式.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事</p>\n<h4 id=\"跨域的含义\"><a href=\"#跨域的含义\" class=\"headerlink\" title=\"跨域的含义\"></a>跨域的含义</h4><p>跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 页面去请求 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</p>\n<h4 id=\"为什么浏览器要限制跨域访问呢？\"><a href=\"#为什么浏览器要限制跨域访问呢？\" class=\"headerlink\" title=\"为什么浏览器要限制跨域访问呢？\"></a>为什么浏览器要限制跨域访问呢？</h4><p>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：</p>\n<ul>\n<li>用户访问<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器</li>\n<li>用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 <a href=\"http://www.xiee.com\" target=\"_blank\" rel=\"noopener\">www.xiee.com</a></li>\n<li>这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> 的操作。 </li>\n<li>如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。</li>\n</ul>\n<h4 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h4><p>看到这，我要吐个槽，在我以前面试的经历当中，有一位年轻的面试官，问了我一个问题，怎么解决跨域，我说通过nginx反向代理，他跟我说，没用过jsonp么，那个表情，好比再说，你连jsonp都不知道么。所以说，技术面试，一般不仅仅是对面试者的考验，更是面的人的一种考验。</p>\n<p>继续咱们的！！！</p>\n<p>不知道同学们有木有用过vue-cli脚手架，在config/index.js中有一段本地开发如何解决跨域的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxyTable: &#123;</span><br><span class=\"line\">    &apos;/apis&apos;: &#123;</span><br><span class=\"line\">        target: &apos;http://xxx/&apos;,</span><br><span class=\"line\">        changeOrigin: true,</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/apis&apos;: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>首先让我们来看看这个东西实现的原理，</p>\n<p>他依赖的是http-proxy-middleware，了解它的自行百度</p>\n<p>这段代码的意思就是，本地反向代理。此原理同样应用到服务器端，在nginx上，配置一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~/apis/&#123;</span><br><span class=\"line\">\trewrite ^/apis/(.*)$ /$1 break;</span><br><span class=\"line\">\tproxy_pass http://xxx/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下做一个解释</p>\n<p>1.’^~ /apis/ ‘</p>\n<ul>\n<li>这是是一个匹配规则，用于拦截请求，匹配任何以 /apis/开头的地址，匹配符合以后，停止往下搜索正则。</li>\n</ul>\n<p>2.rewrite ^/apis/(.*)$ /$1 break;</p>\n<ul>\n<li>代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如<a href=\"http://www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。\" target=\"_blank\" rel=\"noopener\">www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。</a></li>\n</ul>\n<p>　　<em> rewrite后面的参数是一个简单的正则 ^/apis/(.</em>)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。</p>\n<p>　　* break代表匹配一个之后停止匹配。</p>\n<p>3.proxy_pass</p>\n<ul>\n<li><p>既是把请求代理到其他主机，其中 <a href=\"http://www.b.com/\" target=\"_blank\" rel=\"noopener\">http://www.b.com/</a> 写法和 <a href=\"http://www.b.com写法的区别如下\" target=\"_blank\" rel=\"noopener\">http://www.b.com写法的区别如下</a>:</p>\n</li>\n<li><p>不带/</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/&#123;</span><br><span class=\"line\">　　proxy_pass http://b.com:8300; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>带/</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/ &#123; </span><br><span class=\"line\">    proxy_pass http://b.com:8300/; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种配置，区别只在于proxy_pass转发的路径后是否带 “/”。</p>\n<ul>\n<li><p>针对情况1，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/</a> 作为根路径，请求test/路径下的资源。</p>\n</li>\n<li><p>针对情况2，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会变为\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会变为</a> <a href=\"http://proxy_pass/test.jsp，直接访问server的根资源。\" target=\"_blank\" rel=\"noopener\">http://proxy_pass/test.jsp，直接访问server的根资源。</a></p>\n</li>\n</ul>\n<p>修改配置后重启nginx代理就成功了。</p>\n<p>至此，我们的跨域问题配置大功告成。</p>\n<p>有什么疑问，可以上github，有我的练习方式，欢迎大家指正。</p>\n","categories":[],"tags":[]}