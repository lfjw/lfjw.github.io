{"total":17,"pageSize":10,"pageCount":2,"data":[{"title":"git实际开发遇到的问题以及解决方式","slug":"git实际开发遇到的问题以及解决方式","date":"2018-05-18T06:03:32.000Z","updated":"2018-05-18T06:17:09.000Z","comments":true,"path":"api/articles/git实际开发遇到的问题以及解决方式.json","excerpt":"","keywords":null,"cover":null,"content":"<p>在实际工作当中，我们会遇到git的一些问题，总结了一些解决方法</p>\n<h2 id=\"1、git-如何把远程分支搞下来\"><a href=\"#1、git-如何把远程分支搞下来\" class=\"headerlink\" title=\"1、git 如何把远程分支搞下来\"></a>1、git 如何把远程分支搞下来</h2><p>当我想从远程仓库里拉取一条本地不存在的分支时</p>\n<p>git checkout -b 本地分支名 origin/远程分支名</p>\n<p>如果出现提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.</span><br><span class=\"line\">Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</span><br></pre></td></tr></table></figure>\n<p>表示拉取不成功。我们需要先执行</p>\n<p>git fetch</p>\n<p>然后再执行</p>\n<p>git checkout -b 本地分支名 origin/远程分支名</p>\n<p>即可。</p>\n<h2 id=\"2、本地检出一个新的分支并推送到远程仓库\"><a href=\"#2、本地检出一个新的分支并推送到远程仓库\" class=\"headerlink\" title=\"2、本地检出一个新的分支并推送到远程仓库\"></a>2、本地检出一个新的分支并推送到远程仓库</h2><ul>\n<li>创建本地分支</li>\n</ul>\n<p>git checkout -b 新分支名</p>\n<p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上检出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p>\n<p>比如我要创建一个名为dev1的新分支：</p>\n<p>此时，再执行git branch查看当前本地所有分支，就会看到两个分支：master与dev1.</p>\n<ul>\n<li>推送本地分支到远程仓库</li>\n</ul>\n<p>git push –set-upstream origin 分支名</p>\n<!-- https://www.cnblogs.com/hamsterPP/p/6810831.html\n -->\n","text":"在实际工作当中，我们会遇到git的一些问题，总结了一些解决方法1、git 如何把远程分支搞下来当我想从远程仓库里拉取一条本地不存在的分支时git checkout -b 本地分支名 origin/远程分支名如果出现提示：1<br>2<br>fatal: Cannot update","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"深入了解跨域问题，以及解决的方式","slug":"深入了解跨域问题，以及解决的方式","date":"2018-05-09T01:29:28.000Z","updated":"2018-05-09T09:39:51.000Z","comments":true,"path":"api/articles/深入了解跨域问题，以及解决的方式.json","excerpt":"","keywords":null,"cover":null,"content":"<p>对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事</p>\n<h4 id=\"跨域的含义\"><a href=\"#跨域的含义\" class=\"headerlink\" title=\"跨域的含义\"></a>跨域的含义</h4><p>跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 页面去请求 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</p>\n<h4 id=\"为什么浏览器要限制跨域访问呢？\"><a href=\"#为什么浏览器要限制跨域访问呢？\" class=\"headerlink\" title=\"为什么浏览器要限制跨域访问呢？\"></a>为什么浏览器要限制跨域访问呢？</h4><p>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：</p>\n<ul>\n<li>用户访问<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器</li>\n<li>用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 <a href=\"http://www.xiee.com\" target=\"_blank\" rel=\"noopener\">www.xiee.com</a></li>\n<li>这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对<a href=\"http://www.mybank.com\" target=\"_blank\" rel=\"noopener\">www.mybank.com</a> 的操作。 </li>\n<li>如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。</li>\n</ul>\n<h4 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h4><p>看到这，我要吐个槽，在我以前面试的经历当中，有一位年轻的面试官，问了我一个问题，怎么解决跨域，我说通过nginx反向代理，他跟我说，没用过jsonp么，那个表情，好比再说，你连jsonp都不知道么。所以说，技术面试，一般不仅仅是对面试者的考验，更是面的人的一种考验。</p>\n<p>继续咱们的！！！</p>\n<p>不知道同学们有木有用过vue-cli脚手架，在config/index.js中有一段本地开发如何解决跨域的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxyTable: &#123;</span><br><span class=\"line\">    &apos;/apis&apos;: &#123;</span><br><span class=\"line\">        target: &apos;http://xxx/&apos;,</span><br><span class=\"line\">        changeOrigin: true,</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/apis&apos;: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>首先让我们来看看这个东西实现的原理，</p>\n<p>他依赖的是http-proxy-middleware，了解它的自行百度</p>\n<p>这段代码的意思就是，本地反向代理。此原理同样应用到服务器端，在nginx上，配置一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~/apis/&#123;</span><br><span class=\"line\">\trewrite ^/apis/(.*)$ /$1 break;</span><br><span class=\"line\">\tproxy_pass http://xxx/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下做一个解释</p>\n<p>1.’^~ /apis/ ‘</p>\n<ul>\n<li>这是是一个匹配规则，用于拦截请求，匹配任何以 /apis/开头的地址，匹配符合以后，停止往下搜索正则。</li>\n</ul>\n<p>2.rewrite ^/apis/(.*)$ /$1 break;</p>\n<ul>\n<li>代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如<a href=\"http://www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。\" target=\"_blank\" rel=\"noopener\">www.c.com/apis/api/msg?method=1&amp;para=2重写。只对/apis/api/msg重写。</a></li>\n</ul>\n<p>　　<em> rewrite后面的参数是一个简单的正则 ^/apis/(.</em>)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。</p>\n<p>　　* break代表匹配一个之后停止匹配。</p>\n<p>3.proxy_pass</p>\n<ul>\n<li><p>既是把请求代理到其他主机，其中 <a href=\"http://www.b.com/\" target=\"_blank\" rel=\"noopener\">http://www.b.com/</a> 写法和 <a href=\"http://www.b.com写法的区别如下\" target=\"_blank\" rel=\"noopener\">http://www.b.com写法的区别如下</a>:</p>\n</li>\n<li><p>不带/</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/&#123;</span><br><span class=\"line\">　　proxy_pass http://b.com:8300; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>带/</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /apis/ &#123; </span><br><span class=\"line\">    proxy_pass http://b.com:8300/; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种配置，区别只在于proxy_pass转发的路径后是否带 “/”。</p>\n<ul>\n<li><p>针对情况1，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/apis/test.jsp，将test/</a> 作为根路径，请求test/路径下的资源。</p>\n</li>\n<li><p>针对情况2，如果访问url = <a href=\"http://server/apis/test.jsp，则被nginx代理后，请求路径会变为\" target=\"_blank\" rel=\"noopener\">http://server/apis/test.jsp，则被nginx代理后，请求路径会变为</a> <a href=\"http://proxy_pass/test.jsp，直接访问server的根资源。\" target=\"_blank\" rel=\"noopener\">http://proxy_pass/test.jsp，直接访问server的根资源。</a></p>\n</li>\n</ul>\n<p>修改配置后重启nginx代理就成功了。</p>\n<p>至此，我们的跨域问题配置大功告成。</p>\n<p>有什么疑问，可以上github，有我的练习方式，欢迎大家指正。</p>\n","text":"对于前后端分离的项目，跨域问题是必然会遇到的问题，有些同学可能去的公司没有从0开始搭建，被前人解决掉了，没有亲身遇到。那我将会从我参与到的从0开始搭建的项目，来说说跨域的那些事跨域的含义跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com 页面去请求 ","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"使用nuxt","slug":"使用nuxt","date":"2018-05-07T09:59:11.000Z","updated":"2018-05-09T09:38:49.000Z","comments":true,"path":"api/articles/使用nuxt.json","excerpt":"","keywords":null,"cover":null,"content":"<p>关于nuxt，我在这里就不过多介绍了</p>\n<p><a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/</a></p>\n<p>大家可以自行查看</p>\n","text":"关于nuxt，我在这里就不过多介绍了https://zh.nuxtjs.org/大家可以自行查看","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"手把手教你撸electron","slug":"手把手教你撸electron","date":"2018-05-06T11:18:00.000Z","updated":"2018-05-09T09:39:26.000Z","comments":true,"path":"api/articles/手把手教你撸electron.json","excerpt":"","keywords":null,"cover":null,"content":"<p>electron 就不多介绍了，大家可以自行百度查看。</p>\n<p>那么接下来，结合我实际的经验教大家如何快速的搭建一个自己的electron案例</p>\n<p>我们使用的是<a href=\"https://github.com/SimulatedGREG/electron-vue\" target=\"_blank\" rel=\"noopener\">https://github.com/SimulatedGREG/electron-vue</a></p>\n<p>大家可以自行查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">npm install -g vue-cli</span><br><span class=\"line\"></span><br><span class=\"line\">vue init simulatedgreg/electron-vue my-project</span><br><span class=\"line\"></span><br><span class=\"line\">cd my-project</span><br><span class=\"line\"></span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<p>在这里安装的时候会咨询你选择</p>\n<p>electron-builder和electron-packager</p>\n<p>个人建议 electron-builder</p>\n","text":"electron 就不多介绍了，大家可以自行百度查看。那么接下来，结合我实际的经验教大家如何快速的搭建一个自己的electron案例我们使用的是https://github.com/SimulatedGREG/electron-vue大家可以自行查看1<br>2<br>3<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？","slug":"使用Vuejs-Vue-router-开发单页面，如何使得切换页面时能销毁原组件？","date":"2018-05-05T13:55:49.000Z","updated":"2018-05-09T09:38:53.000Z","comments":true,"path":"api/articles/使用Vuejs-Vue-router-开发单页面，如何使得切换页面时能销毁原组件？.json","excerpt":"","keywords":null,"cover":null,"content":"<p>问题：(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？<br>描述:</p>\n<p>我有一个单页面应用，有页面A和页面B，二者是同级组件，关系是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.map(&#123;</span><br><span class=\"line\">&apos;/a&apos;: &#123;</span><br><span class=\"line\">    component: A</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;/b&apos;: &#123;</span><br><span class=\"line\">    component: B</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>例如，第一次打开时，显示页面 A，页面 A 有一个setInterval事件，每隔一秒钟会向后台发送一个Ajax请求。这时我点击页面 A 上的跳转按钮，跳到页面 B，通过观察网络连接，发现页面 A 上的Ajax请求仍然在继续。</p>\n<p>请问应当进行什么样的设置，才能使得页面切换时，原来的组件就被销毁？</p>\n<p>这是个非常严重的问题，同级组件绑定的事件，还会在另一个组件里继续监听。所以我猜想会有简单的配置方法，但我看遍了 Vue 的文档和 Vue-router 的文档，也未发现相关配置。</p>\n<p>参考文档：</p>\n<p><a href=\"http://vuejs.github.io/vue-router/zh-cn/options.html\" target=\"_blank\" rel=\"noopener\">http://vuejs.github.io/vue-router/zh-cn/options.html</a></p>\n<p><a href=\"http://vuejs.org/guide/\" target=\"_blank\" rel=\"noopener\">http://vuejs.org/guide/</a></p>\n<p>解决方案1:</p>\n<p>1、setInterval事件和组件的生命周期没有直接关系。<br>2、setInterval会返回一个ID 值。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</p>\n<p>解决方案2:</p>\n<p>router切换时，原来的组件确实已经销毁了，你可以看到ready生命周期函数是每次都触发了的。你这里的问题不在于组件是否销毁，因为setInterval事件本身和组件没有关系。</p>\n<p>setInterval相当于该组件申请的一种资源，在使用该组件时获取，在离开该组件时释放。这个过程只能是你手动进行的。所以你应该在离开该组件时，比如route的deactivate或者beforeDestory生命周期函数里手动clearInterval。</p>\n<p>其实很多框架里都是这样，比如桌面程序中某个窗口初始化时需要打开数据库连接（我们也可以视为一种资源），当窗口关闭时，程序本身并不知道“打开数据库连接”的反向操作是什么。所以我们需要在窗口销毁的回调方法里手动去释放这个资源，去写断开连接的代码。</p>\n<p>解决方案3:</p>\n<p><a href=\"http://stackoverflow.com/questions/35104770/how-to-destroy-a-component-when-building-spa-with-vue-js-and-vue-router\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/35104770/how-to-destroy-a-component-when-building-spa-with-vue-js-and-vue-router</a></p>\n<p><a href=\"http://vuejs.github.io/vue-router/zh-cn/pipeline/deactivate.html\" target=\"_blank\" rel=\"noopener\">http://vuejs.github.io/vue-router/zh-cn/pipeline/deactivate.html</a></p>\n<p>以上介绍了“(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？”的问题解答，希望对有需要的网友有所帮助。<br>本文网址链接：<a href=\"http://www.codes51.com/itwd/1037580.html\" target=\"_blank\" rel=\"noopener\">http://www.codes51.com/itwd/1037580.html</a></p>\n<p>最后我根据解决方案1解决了，贴下我的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">created () &#123;</span><br><span class=\"line\">  this.n = setInterval(() =&gt; &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  &#125;, 20000)</span><br><span class=\"line\">  this.n1 = setInterval(() =&gt; &#123;</span><br><span class=\"line\">     //...</span><br><span class=\"line\">  &#125;, 60000)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">beforeDestroy () &#123;</span><br><span class=\"line\">  clearInterval(this.n)</span><br><span class=\"line\">  clearInterval(this.n1)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","text":"问题：(javascript)使用Vuejs + Vue-router 开发单页面，如何使得切换页面时能销毁原组件？<br>描述:我有一个单页面应用，有页面A和页面B，二者是同级组件，关系是这样的：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>r","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"elementui中el-upload自定义上传方法中遇到的问题","slug":"elementui中el-upload自定义上传方法中遇到的问题","date":"2018-05-04T12:44:50.000Z","updated":"2018-05-09T09:40:02.000Z","comments":true,"path":"api/articles/elementui中el-upload自定义上传方法中遇到的问题.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\"><a href=\"#由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\" class=\"headerlink\" title=\"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。\"></a>由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">el-upload</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"upload-demo\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">ref</span>=<span class=\"string\">\"upload\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">action</span>=<span class=\"string\">\"http://127.0.0.1:5000/json/import\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:http-request</span>=<span class=\"string\">\"myUpload\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-preview</span>=<span class=\"string\">\"handlePreview\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-remove</span>=<span class=\"string\">\"handleRemove\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-error</span>=<span class=\"string\">\"handleError\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:on-success</span>=<span class=\"string\">\"handleSuccess\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:file-list</span>=<span class=\"string\">\"fileList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:auto-upload</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-button</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"trigger\"</span> <span class=\"attr\">size</span>=<span class=\"string\">\"small\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"primary\"</span>&gt;</span>选取文件<span class=\"tag\">&lt;/<span class=\"name\">el-button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-button</span> <span class=\"attr\">style</span>=<span class=\"string\">\"margin-left: 10px;\"</span> <span class=\"attr\">size</span>=<span class=\"string\">\"small\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"success\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"submitUpload\"</span>&gt;</span>上传到服务器<span class=\"tag\">&lt;/<span class=\"name\">el-button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"tip\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"el-upload__tip\"</span>&gt;</span>只能上传json文件，且不超过500kb<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myUpload(content) &#123;</span><br><span class=\"line\">    console.log(‘myUpload...‘);</span><br><span class=\"line\">    this.$axios(&#123;</span><br><span class=\"line\">        method: ‘post‘,</span><br><span class=\"line\">        url: content.action,</span><br><span class=\"line\">        timeout: 20000,</span><br><span class=\"line\">        data: content.file</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">         content.onSuccess(‘配时文件上传成功‘)</span><br><span class=\"line\">    &#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">        if (error.response) &#123;</span><br><span class=\"line\">             // The request was made and the server responded with a status code</span><br><span class=\"line\">             // that falls out of the range of 2xx</span><br><span class=\"line\">             content.onError(‘配时文件上传失败(‘ + error.response.status + ‘)，‘ + error.response.data);</span><br><span class=\"line\">        &#125; else if (error.request) &#123;</span><br><span class=\"line\">             // The request was made but no response was received</span><br><span class=\"line\">             // `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span><br><span class=\"line\">             // http.ClientRequest in node.js</span><br><span class=\"line\">            content.onError(‘配时文件上传失败，服务器端无响应‘);</span><br><span class=\"line\">       \t&#125; else &#123;</span><br><span class=\"line\">             // Something happened in setting up the request that triggered an Error</span><br><span class=\"line\">             content.onError(‘配时文件上传失败，请求封装失败‘);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式很常见，唯一要注意的点是在上传方法调用后判断结果成功或者失败的时候，需要回调el-upload控件的onSuccess和onError方法，为的是能够复用el-upload原生的一些动作，比如如果成功了，页面上的文件列表会有一个绿勾标记上传成功的文件，如果失败则会把失败的文件从文件列表中删除，如果不回调是没有这些功能的。</p>\n","text":"由于el-upload控件中自定义的upload方法在上传文件中是以FormData的格式上传，后台服务器无法解析这种格式的body，所以通过http-request属性自定义了一个上传方法。1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"cordova安装及使用之android篇","slug":"cordova安装及使用之android篇","date":"2018-04-28T09:52:56.000Z","updated":"2018-05-09T09:39:57.000Z","comments":true,"path":"api/articles/cordova安装及使用之android篇.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"机型：mac\"><a href=\"#机型：mac\" class=\"headerlink\" title=\"机型：mac\"></a>机型：mac</h3><h3 id=\"本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\"><a href=\"#本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\" class=\"headerlink\" title=\"本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本\"></a>本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本</h3><h3 id=\"纯属个人瞎搞，如果有不对的地方欢迎指正\"><a href=\"#纯属个人瞎搞，如果有不对的地方欢迎指正\" class=\"headerlink\" title=\"纯属个人瞎搞，如果有不对的地方欢迎指正\"></a>纯属个人瞎搞，如果有不对的地方欢迎指正</h3><p>先进入正题，使用此cordova首先是配备java环境，然后安装android-sdk</p>\n<p>一、安装jdk以及环境变量</p>\n<p>MAC系统安装JDK1.8及环境变量配置 👉 <a href=\"https://blog.csdn.net/deliciousion/article/details/78046007\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/deliciousion/article/details/78046007</a></p>\n<ul>\n<li><p>下载：jdk下载  👉 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n</li>\n<li><p>Mac设置安卓sdk环境变量   👉 <a href=\"https://blog.csdn.net/free_co/article/details/77115920\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/free_co/article/details/77115920</a></p>\n</li>\n</ul>\n<p>以下是我的配置</p>\n<p>设置JAVA_HOME环境变量，指定为JDK安装路径<br>设置ANDROID_HOME环境变量，指定为Android SDK安装路径<br>同时也建议你添加Android SDK的tools和platform-tools目录到你的PATH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</span><br><span class=\"line\">export ANDROID_HOME=/Users/你的用户名/library/Android/sdk</span><br><span class=\"line\">export PATH=$&#123;PATH&#125;:/Users/你的用户名/library/Android/sdk/platform-tools:/Users/你的用户名/library/Android/sdk/tool</span><br></pre></td></tr></table></figure>\n","text":"机型：mac本篇文章是我根据我的电脑来做，所以针对的是mac的童鞋，如果接下来有时间，将会推出window版本纯属个人瞎搞，如果有不对的地方欢迎指正先进入正题，使用此cordova首先是配备java环境，然后安装android-sdk一、安装jdk以及环境变量MAC系统安装JDK","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"如何查看页面是否开启了gzip压缩","slug":"如何查看页面是否开启了gzip压缩","date":"2018-04-27T12:35:44.000Z","updated":"2018-05-09T09:39:15.000Z","comments":true,"path":"api/articles/如何查看页面是否开启了gzip压缩.json","excerpt":"","keywords":null,"cover":"/2018/04/27/如何查看页面是否开启了gzip压缩/gzip.jpeg","content":"<h3 id=\"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\"><a href=\"#前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\" class=\"headerlink\" title=\"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。\"></a>前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研究明白，也好跟他沟通啊。</h3><h3 id=\"既然如此，让我们从以下几个方面说起\"><a href=\"#既然如此，让我们从以下几个方面说起\" class=\"headerlink\" title=\"既然如此，让我们从以下几个方面说起\"></a>既然如此，让我们从以下几个方面说起</h3><h4 id=\"HTTP-协议中的-Content-Encoding\"><a href=\"#HTTP-协议中的-Content-Encoding\" class=\"headerlink\" title=\"HTTP 协议中的 Content-Encoding\"></a>HTTP 协议中的 Content-Encoding</h4><pre><code>Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。\n工作原理：\n1、浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；\n2、服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；\n3、浏览器拿到响应正文后，依据 Content-Encoding 进行解压。\n4、当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。\n</code></pre><p>【内容编码】目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过 gzip 压缩过的文本响应，只有原始大小的 1/4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于 JPG / PNG 这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费 CPU。</p>\n<ul>\n<li><p>DEFLATE、ZLIB、GZIP 这种大写字符，表示数据压缩格式；</p>\n</li>\n<li><p>deflate、gzip 这种小写字符，表示 HTTP 中 Content-Encoding 的取值；</p>\n</li>\n<li><p>Gzip 特指 GUN zip 文件压缩程序，Zlib 特指 Zlib 库；</p>\n</li>\n</ul>\n<h4 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h4><p>这个详细内容请查看这个 👉 （Nginx配置详解）<a href=\"https://www.cnblogs.com/brant/p/7209048.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/brant/p/7209048.html</a></p>\n<h4 id=\"详解gzip\"><a href=\"#详解gzip\" class=\"headerlink\" title=\"详解gzip\"></a>详解gzip</h4><p>gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；</p>\n<p>Gzip压缩传输能更加有效节约带宽流量。他先把文本压缩为.gz然后传输给浏览器，最后由浏览器负责解压缩呈现给用户。</p>\n<p>老版本的浏览器可能不能显示，但是现在大多数浏览器都能显示。</p>\n<h4 id=\"如何查看是否开启gizp\"><a href=\"#如何查看是否开启gizp\" class=\"headerlink\" title=\"如何查看是否开启gizp\"></a>如何查看是否开启gizp</h4><h5 id=\"先来看看开启的请求\"><a href=\"#先来看看开启的请求\" class=\"headerlink\" title=\"先来看看开启的请求\"></a>先来看看开启的请求</h5><p><img src=\"/2018/04/27/如何查看页面是否开启了gzip压缩/gzip.jpeg\" style=\"height: 500px;width: auto;\"></p>\n<h5 id=\"再来看看没开启的请求\"><a href=\"#再来看看没开启的请求\" class=\"headerlink\" title=\"再来看看没开启的请求\"></a>再来看看没开启的请求</h5><p><img src=\"/2018/04/27/如何查看页面是否开启了gzip压缩/nogzip.jpeg\" style=\"height: 500px;width: auto;\"></p>\n<p>看到这个就可以给你的小伙伴说了，看吧，人家的开启了，你没开启，自己研究研究吧！！！</p>\n","text":"前情简要：我们是前后端分离项目，通过nginx进行反向代理。vue由于是客户端渲染，所以项目很大。我让运维的小伙伴，帮忙在服务器端配置一下开启gzip传输，结果人家说，nginx默认就是这个请求。明显是欺负哥们不懂呐，也可能是没有get到我的点。但是你也没脾气，怎么办，那就自己研","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"小程序api封装","slug":"小程序api封装","date":"2018-04-27T12:16:59.000Z","updated":"2018-05-09T09:39:21.000Z","comments":true,"path":"api/articles/小程序api封装.json","excerpt":"","keywords":null,"cover":null,"content":"<p>微信小程序如今很火热🔥，尤其对于开发者来说，支持的越来越好。例如美团的框架mpvue的推出更是让小程序的开发表的高效。</p>\n<p>mpvue传送门 👉<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var API_URL = &quot;http://xxx&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//请求</span><br><span class=\"line\">var requestHandler = &#123;</span><br><span class=\"line\">    url: &apos;&apos;,</span><br><span class=\"line\">    params:&#123;&#125;,</span><br><span class=\"line\">    success: function(res)&#123;</span><br><span class=\"line\">        // success</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: function() &#123;</span><br><span class=\"line\">        // fail</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    complete: function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//接口统一状态码</span><br><span class=\"line\">var code = &#123;</span><br><span class=\"line\">    &quot;success&quot;: 1,</span><br><span class=\"line\">    &quot;fail&quot;: 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//GET请求</span><br><span class=\"line\">function GET(requestHandler) &#123;</span><br><span class=\"line\">    request(&apos;GET&apos;,requestHandler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//POST请求</span><br><span class=\"line\">function POST(requestHandler) &#123;</span><br><span class=\"line\">    request(&apos;POST&apos;,requestHandler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function request(method,requestHandler) &#123;</span><br><span class=\"line\">    //注意：可以对params加密等处理</span><br><span class=\"line\">    var params = requestHandler.params;</span><br><span class=\"line\"></span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">    \t//默认为API_URL，当输入url变更为https://XXX 以url变化的为主</span><br><span class=\"line\">\t    url: /^\\s*http\\s*/gi.test(requestHandler.url) ? requestHandler.url : API_URL + requestHandler.url,</span><br><span class=\"line\">\t    data: params,</span><br><span class=\"line\">\t    method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT</span><br><span class=\"line\">\t    header: &#123;\t\t// 设置请求的 header</span><br><span class=\"line\">\t    \t&apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">\t    &#125;, </span><br><span class=\"line\">\t    success: function(res)&#123;</span><br><span class=\"line\">\t        //注意：可以对参数解密等处理</span><br><span class=\"line\">\t        //requestHandler.success()</span><br><span class=\"line\">\t        if (res.data &amp;&amp; res.data.code == code.success)&#123;</span><br><span class=\"line\">\t          \trequestHandler.success &amp;&amp; requestHandler.success(res.data);</span><br><span class=\"line\">\t        &#125;else&#123;</span><br><span class=\"line\">\t          \twx.showModal(&#123;</span><br><span class=\"line\">\t            \ttitle: &apos;数据加载失败&apos;,</span><br><span class=\"line\">\t            \tcontent: res.data.message || &apos;服务异常，请稍后重试~&apos;,</span><br><span class=\"line\">\t          \t&#125;);</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    &#125;,</span><br><span class=\"line\">\t    fail: function() &#123;</span><br><span class=\"line\">\t        requestHandler.fail()</span><br><span class=\"line\">\t    &#125;,</span><br><span class=\"line\">\t    complete: function() &#123;</span><br><span class=\"line\">\t        // complete</span><br><span class=\"line\">\t        requestHandler.complete()</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  \tGET: GET,</span><br><span class=\"line\">  \tPOST: POST</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"微信小程序如今很火热🔥，尤其对于开发者来说，支持的越来越好。例如美团的框架mpvue的推出更是让小程序的开发表的高效。mpvue传送门 👉http://mpvue.com/1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>1","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"函数式编程和面向对象编程的区别和优劣","slug":"函数式编程和面向对象编程的区别和优劣","date":"2018-04-27T05:27:42.000Z","updated":"2018-05-09T09:39:05.000Z","comments":true,"path":"api/articles/函数式编程和面向对象编程的区别和优劣.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"一、先来看一下两者的定义\"><a href=\"#一、先来看一下两者的定义\" class=\"headerlink\" title=\"一、先来看一下两者的定义\"></a>一、先来看一下两者的定义</h3><ul>\n<li><p>【函数式编程】顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。这种编程最重要的基础是λ演算，接受函数当作输入和输出。</p>\n</li>\n<li><p>【面向对象编程】这种编程是把问题看作由对象的属性与对象所进行的行为组成。基于对象的概念，以类作为对象的模板，把类和继承作为构造机制，以对象为中心，来思考并解决问题。</p>\n</li>\n</ul>\n<h3 id=\"二、优点\"><a href=\"#二、优点\" class=\"headerlink\" title=\"二、优点\"></a>二、优点</h3><ul>\n<li><p>【函数式编程】支持闭包和高阶函数，闭包是一种可以起函数的作用并可以如对象般操作的对象；而高阶函数是可以以另一个函数作为输入值来进行编程。支持惰性计算，这就可以在求值需要表达式的值得时候进行计算，而不是固定在变量时计算。还有就是可以用递归作为控制流程。函数式编程所编程出来的代码相对而言少很多，而且更加简洁明了。</p>\n</li>\n<li><p>【面向对象编程】面向对象有三个主要特征，分别是封装性、继承性和多态性。类的说明展现了封装性，类作为对象的模板，含有私有数据和公有数据，封装性能使数据更加安全依赖的就是类的特性，使得用户只能看到对象的外在特性，不能看到对象的内在属性，用户只能访问公有数据不能直接访问到私有数据。类的派生功能展现了继承性，继承性是子类共享父类的机制，但是由于封装性，继承性也只限于公有数据的继承（还有保护数据的继承），子类在继承的同时还可以进行派生。而多态性是指对象根据接收的信息作出的行为的多态，不同对象接收同一信息会形成多种行为。</p>\n</li>\n</ul>\n<h3 id=\"三、缺点\"><a href=\"#三、缺点\" class=\"headerlink\" title=\"三、缺点\"></a>三、缺点</h3><ul>\n<li><p>【函数式编程】所有的数据都是不可以改变的，严重占据运行资源，导致运行速度也不够快。</p>\n</li>\n<li><p>【面向对象编程】为了编写可以重用的代码导致许多无用代码的产生，并且许多人为了面向对象而面向对象导致代码给后期维护带来很多麻烦。</p>\n</li>\n</ul>\n<h3 id=\"四、理解\"><a href=\"#四、理解\" class=\"headerlink\" title=\"四、理解\"></a>四、理解</h3><ul>\n<li><p>【函数式编程】</p>\n<ul>\n<li><p>函数是”第一等公民”</p>\n</li>\n<li><p>只用”表达式”，不用”语句”</p>\n</li>\n<li><p>没有”副作用”</p>\n</li>\n<li><p>不修改状态（由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。）</p>\n</li>\n<li><p>引用透明</p>\n</li>\n<li><p>代码简洁，开发快速</p>\n</li>\n<li><p>接近自然语言，易于理解</p>\n</li>\n<li><p>更方便的代码管理</p>\n</li>\n<li><p>易于”并发编程”</p>\n</li>\n</ul>\n</li>\n<li><p>【面向对象编程】</p>\n<ul>\n<li><p>实例化其实就是把构造函数变成一个对象，但是如果多个新建对象被实例化的时候，其实等于构造函数不断被复制占大量的内存，故对一些需要不对被实例化的构造函数，不适合放太多属性在里面。这个时候就需要用到原型（prototype）</p>\n</li>\n<li><p>对象继承分两种情况，一种是构造函数的继承，一种是原型（prototype）的继承：</p>\n</li>\n<li><p>拷贝继承-我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗</p>\n</li>\n</ul>\n</li>\n</ul>\n","text":"一、先来看一下两者的定义【函数式编程】顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。这种编程最重要的基础是λ演算，接受函数当作输入和输出。【面向对象编程】这种编程是把问题看作由对象的属性与对象所进行的行为组成。基于对象的概念，以类作为对象的模板，把类和继承作","link":"","raw":null,"photos":[],"categories":[],"tags":[]}]}